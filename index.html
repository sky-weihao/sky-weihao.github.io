<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Sky-Weihao的博客</title>
  <meta name="author" content="Weihao Xu">
  
  <meta name="description" content="欢迎光临寒舍">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Sky-Weihao的博客">

  
    <meta property="og:image" content="undefined">
  

  <link href="/avatar.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Sky-Weihao的博客" type="application/atom+xml">
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
<link rel="stylesheet" href="/css/style.css">
  <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-368771XX-X']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>
</html>
<body>
  <header id="header" class='normal_mode'>
    <nav id="main-nav">
  <ul class="container">
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">文档</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
  </header>
  <div id="content" class="container">
    <div id="cover">
	<div id="profile" alt="http://sky-weihao.github.io/img/background.jpg">
		<a href="/">
			<div class="logo">
				<img src="/avatar.png" alt="Profile Picture">
			</div>
			<div id="title">Sky-Weihao的博客</div>
		</a>

		
			<div id="subtitle">欢迎光临寒舍</div>
		
		 <ul class="my-socials">
  
  <li>
  	<a href="https://github.com/sky-weihao" class="github" target="_blank">
  		<i class="fa fa-github"></i>
  	</a>
  </li>
  
  <li>
  	<a href="http://weibo.com/1867935643/profile" class="weibo" target="_blank">
  		<i class="fa fa-weibo"></i>
  	</a>
  </li>
  
 
 <li>
   	<a href="mailto:110458260@qq.com" class="email" target="_blank" title="Email Me">
  		<i class="fa fa-envelope"></i>
  	</a>
 </li>
 
</ul>
	</div>
</div>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2019-05-20T03:04:51.000Z"><a href="/2019/05/20/reuse-block/">周一, 5月 20 2019, 11:04:51 上午</a></time>

  
    <h1 class="title"><a href="/2019/05/20/reuse-block/">项目中使用sqlite数据库使用异常情况总结</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>闲聊：好久没有更新博客啦，近期由于工作上的一些原因，相对来说比之前要有空一点，在逐步整理一下之前在做的一些事情，可是之前做的事情也没有进行太详细严谨的记录，包括怎样重新使用hexo更新文章到blog，还有markdown的语法都已经确实忘记得差不多了，只能逐渐恢复下先更新一点，不过文章先更新上来，文章的质量还要等我熟悉blog这块怎样更新要持续进行优化，感谢大家观看。</p>
<p>项目中使用了fmdb作为sqlite数据库上层封装控件，简单总结一下此前进行数据库数据异常丢失，数据库访问失败的原因情况：<br>1、设置了PRAGMA journal_mode = OFF<br>OFF日志模式让SQLite放弃在开始时创建回滚日志，它会禁用SQLite的原子提交和回滚功能，让ROLLBACK命令不可用。如果使用OFF日志模式的事务在中间某时刻发生崩溃或断电，则数据库文件不能恢复，可能会被损坏。</p>
<p>日志模式<br>SQLite中日志模式主要有DELETE和WAL两种，其他几种比如TRUNCATE，PERSIST，MEMORY基本原理都与DELETE模式相同，不作详细展开。DELETE模式采用影子分页技术(Shadow paging)，DELETE模式下，日志中记录的变更前数据页内容；WAL模式下，日志中记录的是变更后的数据页内容。事务提交时，DELETE模式将日志刷盘，将DB文件刷盘，成功后，再将日志文件清理；WAL模式则是将日志文件刷盘，即可完成提交过程。那么WAL模式下，数据文件何时更新呢？这里引入了检查点概念，检查点的作用就是定期将日志中的新页覆盖DB文件中的老页，并通过参数wal_autocheckpoint来控制检查点时机，达到权衡读写的目的。<br>DELETE模式下，写事务直接更新db-page，并将old-page写入日志，读事务则直接读db-page，因为db-page中保存了提交的所有事务的更新。事务提交后，直接将日志文件删除；若事务需要回滚，则将日志中old-page中的内容覆盖db-page，恢复原始内容。WAL模式下，写事务将更新写到日志文件中，不更新db-page，事务提交时，也不影响db-page，只是将日志持久化而已。若事务回滚，则不将日志写入文件即可。由于最新的数据在日志文件中，那么如何读取到最新的数据呢？WAL模式通过end-mark(事务提交位点)达到这一目的。具体而已，事务开始时，会首先扫描日志文件，获取最近一个end-mark，在读取数据时，首先会判断page是否在wal日志文件中存在，因为同一个page，一定是wal文件中的比db文件中的要新。如果存在，则使用，否则，再从db文件中获取指定的page。从流程上来看，这个过程比较慢，因为极端情况下，每次读都需要扫描wal文件和db文件。为了提高性能，WAL模式中有一个wal-index文件，这个文件记录了页号和该页在WAL文件中的偏移，并且wal-index文件采用共享缓存实现，从文件名也可以看到，后缀是.shm，因此判断page是否在wal文件存在的操作实质是一次内存读。wal-index采用hash表存储，因此查询效率也非常高。与传统的DBMS不同，SQLite中记录的日志，实质是dirty-page，重做实质是对利用WAL中的日志页覆盖db-page，这种实现方式比较简单，同时也比较浪费空间，因为一个page是1k，即使只更新1byte，也会导致日志记录1k。<br>我们可以在数据库建立时就改变日志模式</p>
<p>WAL日志模式优点：<br>1) 读写可以并发，不会阻塞<br>2）只有一个WAL文件，性能优势明显。</p>
<p>2、PRAGMA synchronous = OFF<br>The sync operations that SQLite performs to help ensure integrity can be disabled at run-time using the synchronous pragma. By setting PRAGMA synchronous=OFF, all sync operations are omitted. This makes SQLite seem to run faster, but it also allows the operating system to freely reorder writes, which could result in database corruption if a power failure or hard reset occurs prior to all content reaching persistent storage.<br>For maximum reliability and for robustness against database corruption, SQLite should always be run with its default synchronous setting of FULL.</p>
<p>推荐使用配置：<br>PRAGMA journal_mode = WAL<br>PRAGMA synchronous = NORMAL<br>PRAGMA locking_mode=EXCLUSIVE</p>
<p>同时附上了微信WCDB（也是建立在sqlite上）对数据库属性的默认配置进行参考，其也是开启了wal模式，并且没有对数据库读写synchronous设置为FULL，<br>/**<br>@brief Default config name.<br>The default config for WCDB is :</p>
<ol>
<li>PRAGMA locking_mode=NORMAL</li>
<li>PRAGMA synchronous=NORMAL</li>
<li>PRAGMA journal_mode=WAL</li>
<li>PRAGMA fullfsync=ON<br>Setting config for this name will overwrite the default config.<br>@return default config name<br>*/</li>
</ol>
<p>但无论在任何情况及设计任何配置的情况下，数据库<br>数据库修复策略（目前已知在app里内无法使用.dump命令到sql语句）<br>1、使用sqlite3_backup_init、sqlite3_backup_step、sqlite3_backup_finish方法进行数据库文件备份（目前已经实现）<br>当发现数据库损坏时，使用相对应方法使用备份文件进行修复，使用双重备份提高成功率<br>优点：<br>1、sqlite3库自带方法，使用比较方便<br>2、sqlite网上可查找相关的备份方法说明文档<br>3、恢复快<br>缺点：<br>1、未知修复成功率能达到多少<br>2、压缩后没有dump方法的数据量少 不适合db损坏率较低的场景<br>3、备份耗时比较长<br>4、无法解决用户数据库已损坏情况的恢复</p>
<p>2、自己实现dump方法<br>优点：<br>1、容量小、备份耗时中等<br>2、能针对数据库非master表部分损坏的情况进行修复<br>缺点：<br>1、实现dump的相关执行语句需要自己实现<br>2、恢复慢<br>难度：<br>中等</p>
<p>3、使用微信wcdb repairKit方法进行数据库备份和恢复（研究中）<br>优点：<br>1、微信验证修复成功率达90%以上<br>2、能进行压缩，压缩比较高<br>3、支持加解密<br>4、支持ORM，比fmdb读写速度快<br>缺点：<br>1、需要读懂分析微信wcdb中的代码或者把项目接入从fmdb的使用迁移wcdb到项目中，并去除项目中fmdb的引用。<br>难度：<br>较大</p>
<p>参考文章：<br><a href="https://blog.csdn.net/wql2rainbow/article/details/73650056?utm_source=blogxgwz20" target="_blank" rel="noopener">https://blog.csdn.net/wql2rainbow/article/details/73650056?utm_source=blogxgwz20</a><br><a href="https://www.sqlite.org/wal.html" target="_blank" rel="noopener">https://www.sqlite.org/wal.html</a><br><a href="https://blog.csdn.net/chinaclock/article/details/48622243" target="_blank" rel="noopener">https://blog.csdn.net/chinaclock/article/details/48622243</a><br><a href="http://garyliutw.blogspot.com/2013/07/sqlite_24.html" target="_blank" rel="noopener">http://garyliutw.blogspot.com/2013/07/sqlite_24.html</a><br><a href="http://www.runoob.com/sqlite/sqlite-pragma.html" target="_blank" rel="noopener">http://www.runoob.com/sqlite/sqlite-pragma.html</a></p>

      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2019/05/20/reuse-block/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2019/05/20/reuse-block/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2019/05/20/reuse-block/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-10-06T02:49:41.000Z"><a href="/2015/10/06/Video-streaming-and-caching-in-iOS/">周二, 10月 6 2015, 10:49:41 上午</a></time>

  
    <h1 class="title"><a href="/2015/10/06/Video-streaming-and-caching-in-iOS/">iOS音视频实现边下载边播放</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，原创博客/">博客，原创博客</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>近段时间制作视频播放社区的功能，期间查找了不少资料，做过很多尝试，现在来整理一下其中遇到的一些坑.由于考虑到AVPlayer对视频有更高自由度的控制，而且能够使用它自定义视频播放界面，iOS中所使用的视频播放控件为AVPlayer，而抛弃了高层次的MediaPlayer框架，现在想想挺庆幸当初使用了AVPlayer。</p>
<h3 id="AVPlayer的基本知识">AVPlayer的基本知识</h3><p>AVPlayer本身并不能显示视频，而且它也不像MPMoviePlayerController有一个view属性。如果AVPlayer要显示必须创建一个播放器层AVPlayerLayer用于展示，播放器层继承于CALayer，有了AVPlayerLayer之添加到控制器视图的layer中即可。要使用AVPlayer首先了解一下几个常用的类：</p>
<p>AVAsset：主要用于获取多媒体信息，是一个抽象类，不能直接使用。</p>
<p>AVURLAsset：AVAsset的子类，可以根据一个URL路径创建一个包含媒体信息的AVURLAsset对象。</p>
<p>AVPlayerItem：一个媒体资源管理对象，管理者视频的一些基本信息和状态，一个AVPlayerItem对应着一个视频资源。</p>
<h3 id="iOS视频实现边下载边播放的几种实现">iOS视频实现边下载边播放的几种实现</h3><h4 id="1-本地实现http_server">1.本地实现http server</h4><p>在iOS本地开启Local Server服务，然后使用播放控件请求本地Local Server服务，本地的服务再不断请求视频地址获取视频流，本地服务请求的过程中把视频缓存到本地，这种方法在网上有很多<a href="http://code4app.com/ios/%E8%A7%86%E9%A2%91%E8%BE%B9%E4%B8%8B%E8%BD%BD%E8%BE%B9%E6%92%AD%E6%94%BE/5292c381cb7e8445678b5ac2#" target="_blank" rel="noopener">例子</a>，有兴趣了解的人可自己下载例子查看。</p>
<h4 id="2-使用AVPlayer的方法开启下载服务">2.使用AVPlayer的方法开启下载服务</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">AVURLAsset</span> *urlAsset = [[<span class="built_in">AVURLAsset</span> alloc]initWithURL:url options:<span class="literal">nil</span>];</span><br><span class="line"><span class="number">2.</span><span class="built_in">AVPlayerItem</span> *item = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:urlAsset];</span><br><span class="line"><span class="number">3.</span>[<span class="keyword">self</span>.avPlayer replaceCurrentItemWithPlayerItem:item];</span><br><span class="line"><span class="number">4.</span>[<span class="keyword">self</span> addObserverToPlayerItem:item];</span><br></pre></td></tr></table></figure>
<p>但由于AVPlayer是没有提供方法给我们直接获取它下载下来的数据，所以我们只能在视频下载完之后自己去寻找缓存视频数据的办法，AVFoundation框架中有一种从多媒体信息类AVAsset中提取视频数据的类AVMutableComposition和AVAssetExportSession。<br>其中AVMutableComposition的作用是能够从现有的asset实例中创建出一个新的AVComposition(它也是AVAsset的字类)，使用者能够从别的asset中提取他们的音频轨道或视频轨道，并且把它们添加到新建的Composition中。<br>AVAssetExportSession的作用是把现有的自己创建的asset输出到本地文件中。<br>为什么需要把原先的AVAsset(AVURLAsset)实现的数据提取出来后拼接成另一个AVAsset(AVComposition)的数据后输出呢，由于通过网络url下载下来的视频没有保存视频的原始数据（或者苹果没有暴露接口给我们获取），下载后播放的avasset不能使用AVAssetExportSession输出到本地文件，要曲线地把下载下来的视频通过重构成另外一个AVAsset实例才能输出。代码例子如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">NSString</span> <span class="meta">*documentDirectory</span> <span class="string">=</span> <span class="string">NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,</span> <span class="string">NSUserDomainMask,</span> <span class="literal">YES</span><span class="string">)[0];</span></span><br><span class="line"><span class="string">NSString</span> <span class="meta">*myPathDocument</span> <span class="string">=</span> <span class="string">[documentDirectory</span> <span class="attr">stringByAppendingPathComponent:[NSString</span> <span class="attr">stringWithFormat:@"%@.mp4",[_source.videoUrl</span> <span class="string">MD5]]];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">NSURL</span> <span class="meta">*fileUrl</span> <span class="string">=</span> <span class="string">[NSURL</span> <span class="attr">fileURLWithPath:myPathDocument];</span></span><br><span class="line"></span><br><span class="line"><span class="string">if</span> <span class="string">(asset</span> <span class="string">!=</span> <span class="string">nil)</span> <span class="string">&#123;</span></span><br><span class="line"><span class="string">AVMutableComposition</span> <span class="meta">*mixComposition</span> <span class="string">=</span> <span class="string">[[AVMutableComposition</span> <span class="string">alloc]init];</span></span><br><span class="line"><span class="string">AVMutableCompositionTrack</span> <span class="meta">*firstTrack</span> <span class="string">=</span> <span class="string">[mixComposition</span> <span class="attr">addMutableTrackWithMediaType:AVMediaTypeVideo</span> <span class="attr">preferredTrackID:kCMPersistentTrackID_Invalid];</span></span><br><span class="line"><span class="string">[firstTrack</span> <span class="attr">insertTimeRange:CMTimeRangeMake(kCMTimeZero,</span> <span class="string">asset.duration)</span> <span class="attr">ofTrack:[[asset</span> <span class="attr">tracksWithMediaType:AVMediaTypeVideo]objectAtIndex:0]</span> <span class="attr">atTime:kCMTimeZero</span> <span class="attr">error:nil];</span></span><br><span class="line"></span><br><span class="line"><span class="string">AVMutableCompositionTrack</span> <span class="meta">*audioTrack</span> <span class="string">=</span> <span class="string">[mixComposition</span> <span class="attr">addMutableTrackWithMediaType:AVMediaTypeAudio</span> <span class="attr">preferredTrackID:kCMPersistentTrackID_Invalid];</span></span><br><span class="line"><span class="string">[audioTrack</span> <span class="attr">insertTimeRange:CMTimeRangeMake(kCMTimeZero,</span> <span class="string">asset.duration)</span> <span class="attr">ofTrack:[[asset</span> <span class="attr">tracksWithMediaType:AVMediaTypeAudio]objectAtIndex:0]</span> <span class="attr">atTime:kCMTimeZero</span> <span class="attr">error:nil];</span></span><br><span class="line"></span><br><span class="line"><span class="string">AVAssetExportSession</span> <span class="meta">*exporter</span> <span class="string">=</span> <span class="string">[[AVAssetExportSession</span> <span class="string">alloc]initWithAsset:mixComposition</span> <span class="attr">presetName:AVAssetExportPresetHighestQuality];</span></span><br><span class="line"><span class="string">exporter.outputURL</span> <span class="string">=</span> <span class="string">fileUrl;</span></span><br><span class="line"><span class="string">if</span> <span class="string">(exporter.supportedFileTypes)</span> <span class="string">&#123;</span></span><br><span class="line"><span class="string">exporter.outputFileType</span> <span class="string">=</span> <span class="string">[exporter.supportedFileTypes</span> <span class="attr">objectAtIndex:0]</span> <span class="string">;</span></span><br><span class="line"><span class="string">exporter.shouldOptimizeForNetworkUse</span> <span class="string">=</span> <span class="literal">YES</span><span class="string">;</span></span><br><span class="line"><span class="string">[exporter</span> <span class="attr">exportAsynchronouslyWithCompletionHandler:^&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#125;];</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-使用AVAssetResourceLoader回调下载，也是最终决定使用的技术">3.使用AVAssetResourceLoader回调下载，也是最终决定使用的技术</h3><p>AVAssetResourceLoader通过你提供的委托对象去调节AVURLAsset所需要的加载资源。<strong>而很重要的一点是，AVAssetResourceLoader仅在AVURLAsset不知道如何去加载这个URL资源时才会被调用，就是说你提供的委托对象在AVURLAsset不知道如何加载资源时才会得到调用</strong>。所以我们又要通过一些方法来曲线解决这个问题，把我们目标视频URL地址的scheme替换为系统不能识别的scheme，然后在我们调用网络请求去处理这个URL时把scheme切换为原来的scheme。</p>
<p>实现边下边播功能AVResourceLoader的委托对象必须要实现AVAssetResourceLoaderDelegate下五个协议的其中两个：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">1</span><span class="comment">//在系统不知道如何处理URLAsset资源时回调</span></span><br><span class="line"><span class="selector-tag">-</span> (BOOL)<span class="selector-tag">resourceLoader</span><span class="selector-pseudo">:(AVAssetResourceLoader</span> *)<span class="selector-tag">resourceLoader</span> <span class="selector-tag">shouldWaitForLoadingOfRequestedResource</span><span class="selector-pseudo">:(AVAssetResourceLoadingRequest</span> *)<span class="selector-tag">loadingRequest</span> <span class="selector-tag">NS_AVAILABLE</span>(<span class="number">10</span>_9, <span class="number">6</span>_0);</span><br><span class="line"><span class="selector-tag">2</span><span class="comment">//在取消加载资源后回调</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">resourceLoader</span><span class="selector-pseudo">:(AVAssetResourceLoader</span> *)<span class="selector-tag">resourceLoader</span> <span class="selector-tag">didCancelLoadingRequest</span><span class="selector-pseudo">:(AVAssetResourceLoadingRequest</span> *)<span class="selector-tag">loadingRequest</span> <span class="selector-tag">NS_AVAILABLE</span>(<span class="number">10</span>_9, <span class="number">7</span>_0);</span><br></pre></td></tr></table></figure>
<p>以下来说说具体要怎么做处理</p>
<h4 id="第一步，创建一个AVURLAsset，并且用它来初始化一个AVPlayerItem">第一步，创建一个AVURLAsset，并且用它来初始化一个AVPlayerItem</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define kCustomVideoScheme @<span class="meta-string">"yourScheme"</span></span></span><br><span class="line"><span class="built_in">NSURL</span> *currentURL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://***.***.***"</span>];</span><br><span class="line"><span class="built_in">NSURLComponents</span> *components = [[<span class="built_in">NSURLComponents</span> alloc]initWithURL:currentURL resolvingAgainstBaseURL:<span class="literal">NO</span>];</span><br><span class="line"><span class="number">1</span><span class="comment">////注意，不加这一句不能执行到回调操作</span></span><br><span class="line">components.scheme = kCustomVideoScheme;</span><br><span class="line"><span class="built_in">AVURLAsset</span> *urlAsset = [<span class="built_in">AVURLAsset</span> URLAssetWithURL:components.URL  </span><br><span class="line">options:<span class="literal">nil</span>];</span><br><span class="line"><span class="number">2</span><span class="comment">//_resourceManager在接下来讲述</span></span><br><span class="line">[urlAsset.resourceLoader setDelegate:_resourceManager queue:dispatch_get_main_queue()];</span><br><span class="line"><span class="built_in">AVPlayerItem</span> *item = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:urlAsset];</span><br><span class="line">_playerItem = item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IOS9_OR_LATER) &#123;</span><br><span class="line">item.canUseNetworkResourcesForLiveStreamingWhilePaused = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span>.avPlayer replaceCurrentItemWithPlayerItem:item];</span><br><span class="line"><span class="keyword">self</span>.playerLayer.player = <span class="keyword">self</span>.avPlayer;</span><br><span class="line">[<span class="keyword">self</span> addObserverToPlayerItem:item];**</span><br></pre></td></tr></table></figure>
<h4 id="第二步，创建AVResourceManager实现AVResourceLoader协议">第二步，创建AVResourceManager实现AVResourceLoader协议</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">interface</span> AVAResourceLoaderManager : <span class="type">NSObject</span> &lt; AVAssetResourceLoaderDelegate &gt;</span><br></pre></td></tr></table></figure>
<h4 id="第三步，实现两个必须的回调协议，实现中有几件需要做的事情">第三步，实现两个必须的回调协议，实现中有几件需要做的事情</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">1</span><span class="comment">//获取系统中不能处理的URL</span></span><br><span class="line"><span class="built_in">NSURL</span> *resourceURL = [loadingRequest.request URL];</span><br><span class="line"><span class="number">2</span><span class="comment">//判断这个URL是否遵守URL规范和其是否是我们所设定的URL</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> checkIsLegalURL:resourceURL] &amp;&amp; [resourceURL.scheme isEqualToString:kCustomVideoScheme])&#123;</span><br><span class="line"><span class="number">3</span><span class="comment">//判断当前的URL网络请求是否已经被加载过了，如果缓存中里面有URL对应的网络加载器(自己封装，也可以直接使用NSURLRequest)，则取出来添加请求，每一个URL对应一个网络加载器，loader的实现接下来会说明</span></span><br><span class="line"><span class="built_in">AVResourceLoaderForASI</span> *loader = [<span class="keyword">self</span> asiresourceLoaderForRequest:loadingRequest];</span><br><span class="line"><span class="keyword">if</span> (loader == <span class="literal">nil</span>)&#123;</span><br><span class="line">loader = [[<span class="built_in">AVResourceLoaderForASI</span> alloc] initWithResourceURL:resourceURL];</span><br><span class="line">loader.delegate = <span class="keyword">self</span>;</span><br><span class="line"><span class="number">4</span><span class="comment">//缓存网络加载器</span></span><br><span class="line">[<span class="keyword">self</span>.resourceLoaders setObject:loader forKey:[<span class="keyword">self</span> keyForResourceLoaderWithURL:resourceURL]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span><span class="comment">//加载器添加请求</span></span><br><span class="line">[loader addRequest:loadingRequest];</span><br><span class="line"><span class="number">6</span><span class="comment">//返回YES则表明使用我们的代码对AVAsset中请求网络资源做处理</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader didCancelLoadingRequest:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果用户在下载的过程中调用者取消了获取视频,则从缓存中取消这个请求</span></span><br><span class="line"><span class="built_in">NSURL</span> *resourceURL = [loadingRequest.request URL];</span><br><span class="line"><span class="built_in">NSString</span> *actualURLString = [<span class="keyword">self</span> actualURLStringWithURL:resourceURL];</span><br><span class="line"><span class="built_in">AVResourceLoaderForASI</span> *loader = [_resourceLoaders objectForKey:actualURLString];</span><br><span class="line">[loader removeRequest:loadingRequest];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第四步，判断缓存中是否已下载完视频">第四步，判断缓存中是否已下载完视频</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addRequest:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1判断自身是否已经取消加载</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">self</span>.isCancelled==<span class="literal">NO</span>)&#123;</span><br><span class="line"><span class="comment">//2判断本地中是否已经有文件的缓存，如果有，则直接从缓存中读取数据，文件保存和读取这里不做详述，使用者可根据自身情况创建文件系统</span></span><br><span class="line"><span class="built_in">AVAResourceFile</span> *resourceFile = [<span class="keyword">self</span>.resourceFileManager resourceFileWithURL:<span class="keyword">self</span>.resourceURL];</span><br><span class="line"><span class="keyword">if</span> (resourceFile) &#123;</span><br><span class="line"><span class="comment">//3若本地文件存在，则从文件中获取以下属性  </span></span><br><span class="line">loadingRequest.contentInformationRequest.byteRangeAccessSupported = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">//3.1contentType</span></span><br><span class="line">loadingRequest.contentInformationRequest.contentType = resourceFile.contentType;</span><br><span class="line"><span class="comment">//3.2数据长度          		  </span></span><br><span class="line">loadingRequest.contentInformationRequest.contentLength = resourceFile.contentLength;</span><br><span class="line"><span class="comment">//3.3请求的偏移量</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> requestedOffset = loadingRequest.dataRequest.requestedOffset;</span><br><span class="line"><span class="comment">//3.4请求总长度</span></span><br><span class="line"><span class="built_in">NSInteger</span> requestedLength = loadingRequest.dataRequest.requestedLength;</span><br><span class="line"><span class="comment">//3.5取出本地文件中从偏移量到请求长度的数据</span></span><br><span class="line"><span class="built_in">NSData</span> *subData = [resourceFile.data subdataWithRange:<span class="built_in">NSMakeRange</span>(@(requestedOffset).unsignedIntegerValue, requestedLength)];</span><br><span class="line"><span class="comment">//3.6返回数据给请求</span></span><br><span class="line">[loadingRequest.dataRequest respondWithData:subData];</span><br><span class="line">[loadingRequest finishLoading];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//4如果没有本地文件，则开启网络请求，从网络中获取 ,见第五步 </span></span><br><span class="line">[<span class="keyword">self</span> startWithRequest:loadingRequest];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//5如果已经取消请求，并且请求没有完成，则封装错误给请求，可自己实现</span></span><br><span class="line"><span class="keyword">if</span>(loadingRequest.isFinished==<span class="literal">NO</span>)&#123;</span><br><span class="line">[loadingRequest finishLoadingWithError:[<span class="keyword">self</span> loaderCancelledError]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第五步，添加loadingRequest到网络文件加载器，这部分的操作比较长">第五步，添加loadingRequest到网络文件加载器，这部分的操作比较长</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startWithRequest:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">1</span><span class="comment">//判断当前请求是否已经开启，由于苹果系统原因，会有两次回调到AVResourceLoaderDelegate，我们对其进行判断，只开启一次请求</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.dataTask == <span class="literal">nil</span>)&#123;</span><br><span class="line"><span class="number">2</span><span class="comment">//根据loadingRequest中的URL创建NSURLRequest，注意在此把URL中的scheme修改为原先的scheme</span></span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="keyword">self</span> requestWithLoadingRequest:loadingRequest];</span><br><span class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="number">3</span><span class="comment">//获取url的绝对路径，并使用ASIHttpRequest进行网络请求，下面的请求方法经过封装，就不详说如何对ASI进行封装了，但是每一步需要做的事情能以block的形式更好说明</span></span><br><span class="line"><span class="built_in">NSString</span> *urlString = request.URL.absoluteString;</span><br><span class="line"><span class="keyword">self</span>.dataTask = [<span class="keyword">self</span> GET:urlString requestBlock:^(Request *req) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s %@ ###"</span>, __func__, req);</span><br><span class="line"><span class="number">4</span><span class="comment">//在接受到请求头部信息时，说明链接成功，数据开始传输</span></span><br><span class="line"><span class="keyword">if</span> (req.recvingHeader<span class="comment">//意思是请求接受到头部信息状态)&#123;</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s recvingHeader ###"</span>, __func__);</span><br><span class="line">__<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"><span class="keyword">if</span> ([urlString isEqualToString:req.originalURL.absoluteString]) &#123;</span><br><span class="line"><span class="number">4.1</span><span class="comment">//，创建临时数据保存网络下载下来的视频信息</span></span><br><span class="line">strongSelf.tempData = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4.2</span><span class="comment">//把头部信息内容写入到AVAssetResourceLoadingRequest，即loadingRequest中</span></span><br><span class="line">[strongSelf processPendingRequests];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (req.recving<span class="comment">//请求接受中状态)&#123;</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s recving ###"</span>, __func__);</span><br><span class="line">__<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"><span class="number">5</span><span class="comment">//此处需多次调用把请求的信息写入到loadingRequest的步骤，实现下载的过程中数据能输出到loadingRequest播放</span></span><br><span class="line"><span class="keyword">if</span> (urlString == req.originalURL.absoluteString) &#123;</span><br><span class="line"><span class="number">5.1</span><span class="comment">//这个处理是判断此时返回的头部信息是重定向还是实际视频的头部信息，如果是重定向信息，则不作处理</span></span><br><span class="line"><span class="keyword">if</span> (!_contentInformation &amp;&amp; req.responseHeaders) &#123;</span><br><span class="line"><span class="keyword">if</span> ([req.responseHeaders objectForKey:<span class="string">@"Location"</span>] ) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@" ### %s redirection URL ###"</span>, __func__);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//5.2如果不是重定向信息，则把需要用到的信息提取出来</span></span><br><span class="line">_contentInformation = [[RLContentInformationForASI alloc]init];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> numer = [[req.responseHeaders objectForKey:<span class="string">@"Content-Length"</span>]longLongValue];</span><br><span class="line">_contentInformation.contentLength = numer;</span><br><span class="line">_contentInformation.byteRangeAccessSupported = <span class="literal">YES</span>;</span><br><span class="line">_contentInformation.contentType = [req.responseHeaders objectForKey:<span class="string">@"Content-type"</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.3开始从请求中获取返回数据</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s before tempData length = %lu ###"</span>, __FUNCTION__, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.tempData.length);</span><br><span class="line">strongSelf.tempData = [<span class="built_in">NSMutableData</span> dataWithData:req.rawResponseData];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s after tempData length = %lu ###"</span>,__FUNCTION__, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.tempData.length);</span><br><span class="line"><span class="comment">//5.4把返回数据输出到loadingRequest中</span></span><br><span class="line">[strongSelf processPendingRequests];</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (req.succeed)&#123;</span><br><span class="line"><span class="number">6</span><span class="comment">//请求返回成功，在这里做最后一次把数据输出到loadingRequest，且做一些成功后的事情</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s succeed ###"</span>, __func__);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s tempData length = %lu ###"</span>, __func__, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.tempData.length);</span><br><span class="line">__<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"><span class="keyword">if</span> (strongSelf) &#123;</span><br><span class="line">[strongSelf processPendingRequests];</span><br><span class="line"></span><br><span class="line"><span class="number">7</span><span class="comment">//保存缓存文件，我在保存文件这里做了一次偷懒，如果有人参考我写的文件可对保存文件作改进，在每次返回数据时把数据追加写到文件，而不是下载成功之后才保存，这请求时也可以使用这个来实现断点重输的功能</span></span><br><span class="line"><span class="built_in">AVAResourceFile</span> *resourceFile = [[<span class="built_in">AVAResourceFile</span> alloc]initWithContentType:strongSelf.contentInformation.contentType date:strongSelf.tempData];</span><br><span class="line">[strongSelf.resourceFileManager saveResourceFile:resourceFile withURL:<span class="keyword">self</span>.resourceURL];</span><br><span class="line"><span class="number">8</span><span class="comment">//在此做一些清理缓存、释放对象和回调到上层的操作</span></span><br><span class="line">[strongSelf complete];</span><br><span class="line"><span class="keyword">if</span> (strongSelf.delegate &amp;&amp; [strongSelf.delegate respondsToSelector:<span class="keyword">@selector</span>(resourceLoader:didLoadResource:)]) &#123;</span><br><span class="line">[strongSelf.delegate resourceLoader:strongSelf didLoadResource:strongSelf.resourceURL];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (req.failed)&#123;</span><br><span class="line"><span class="comment">//9如果请求返回失败，则向上层抛出错误，且清理缓存等操作</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s failed ###"</span> , __func__);</span><br><span class="line">[<span class="keyword">self</span> completeWithError:req.error];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span>.pendingRequests addObject:loadingRequest];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第六步，把请求返回数据输出到loadingRequest的操作">第六步，把请求返回数据输出到loadingRequest的操作</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)processPendingRequests</span><br><span class="line">&#123;</span><br><span class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">__<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *requestsCompleted = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="number">1</span><span class="comment">//从缓存信息中找出当前正在请求中的loadingRequest</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">AVAssetResourceLoadingRequest</span> *loadingRequest <span class="keyword">in</span> strongSelf.pendingRequests)&#123;</span><br><span class="line"><span class="number">2</span><span class="comment">//把头部信息输出到loadingRequest中</span></span><br><span class="line">[strongSelf fillInContentInformation:loadingRequest.contentInformationRequest];      </span><br><span class="line"><span class="number">3</span><span class="comment">//把视频数据输出到loadingRequest中</span></span><br><span class="line"><span class="built_in">BOOL</span> didRespondCompletely = [strongSelf respondWithDataForRequest:loadingRequest.dataRequest];</span><br><span class="line"><span class="number">4</span><span class="comment">//在success状态中做最后一次调用的时候，检测到请求已经完成，则从缓存信息中清除loadingRequest，并且把loadingRequest标志为完成处理状态</span></span><br><span class="line"><span class="keyword">if</span> (didRespondCompletely)&#123;</span><br><span class="line">[requestsCompleted addObject:loadingRequest];</span><br><span class="line">[loadingRequest finishLoading];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span><span class="comment">//清理缓存</span></span><br><span class="line">[strongSelf.pendingRequests removeObjectsInArray:requestsCompleted];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">、</span><br><span class="line"></span><br><span class="line"><span class="comment">//把提取出来的头部信息输出到loadingRequest中，可以优化</span></span><br><span class="line">- (<span class="keyword">void</span>)fillInContentInformation:(<span class="built_in">AVAssetResourceLoadingContentInformationRequest</span> *)contentInformationRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (contentInformationRequest == <span class="literal">nil</span> || <span class="keyword">self</span>.contentInformation == <span class="literal">nil</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">contentInformationRequest.byteRangeAccessSupported = <span class="keyword">self</span>.contentInformation.byteRangeAccessSupported;</span><br><span class="line">contentInformationRequest.contentType = <span class="keyword">self</span>.contentInformation.contentType;</span><br><span class="line">contentInformationRequest.contentLength = <span class="keyword">self</span>.contentInformation.contentLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把缓存数据输出到loadingRequest中</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)respondWithDataForRequest:(<span class="built_in">AVAssetResourceLoadingDataRequest</span> *)dataRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> startOffset = dataRequest.requestedOffset;</span><br><span class="line"><span class="keyword">if</span> (dataRequest.currentOffset != <span class="number">0</span>)&#123;</span><br><span class="line">startOffset = dataRequest.currentOffset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don't have any data at all for this request</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.tempData.length &lt; startOffset)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is the total data we have from startOffset to whatever has been downloaded so far</span></span><br><span class="line"><span class="built_in">NSUInteger</span> unreadBytes = <span class="keyword">self</span>.tempData.length - (<span class="built_in">NSUInteger</span>)startOffset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Respond with whatever is available if we can't satisfy the request fully yet</span></span><br><span class="line"><span class="built_in">NSUInteger</span> numberOfBytesToRespondWith = MIN((<span class="built_in">NSUInteger</span>)dataRequest.requestedLength, unreadBytes);</span><br><span class="line"></span><br><span class="line">[dataRequest respondWithData:[<span class="keyword">self</span>.tempData subdataWithRange:<span class="built_in">NSMakeRange</span>((<span class="built_in">NSUInteger</span>)startOffset, numberOfBytesToRespondWith)]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> endOffset = startOffset + dataRequest.requestedLength;</span><br><span class="line"><span class="built_in">BOOL</span> didRespondFully = <span class="keyword">self</span>.tempData.length &gt;= endOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> didRespondFully;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>视频边下边播的流程大致上已经描述完毕，本博文中没有说到的代码有错误处理方式、缓存文件的读写和保存格式、部分内存缓存使用说明、</strong></p>
<p>参考链接：<br><a href="http://www.codeproject.com/Articles/875105/Audio-streaming-and-caching-in-iOS-using" target="_blank" rel="noopener">http://www.codeproject.com/Articles/875105/Audio-streaming-and-caching-in-iOS-using</a><br><a href="http://www.cnblogs.com/kenshincui/p/4186022.html#mpMoviePlayerController" target="_blank" rel="noopener">http://www.cnblogs.com/kenshincui/p/4186022.html#mpMoviePlayerController</a></p>
<p>补充：<br>在开发过程中遇到的一些坑在这里补充一下<br>1.在iOS9后，AVPlayer的replaceCurrentItemWithPlayerItem方法在切换视频时底层会调用信号量等待然后导致当前线程卡顿，如果在UITableViewCell中切换视频播放使用这个方法，会导致当前线程冻结几秒钟。遇到这个坑还真不好在系统层面对它做什么，后来找到的解决方法是在每次需要切换视频时，需重新创建AVPlayer和AVPlayerItem。<br>2.iOS9后，AVFoundation框架还做了几点修改，如果需要切换视频播放的时间，或需要控制视频从头播放调用seekToDate方法，需要保持视频的播放rate大于0才能修改，还有canUseNetworkResourcesForLiveStreamingWhilePaused这个属性，在iOS9前默认为YES，之后默认为NO。<br>3.AVPlayer的replaceCurrentItemWithPlayerItem方法正常是会引用住参数AVPlayerItem的，但在某些情况下导致视频播放失败，它会马上释放对这个对象的持有，假如你对AVPlayerItem的实例对象添加了监听，但是自己没有对item的计数进行管理，不知道什么时候释放这个监听，则会导致程序崩溃。<br>4.为什么我选择第三种方法实现边下边播，第一种方法需要程序引入LocalServer库，需增加大量app包大小，且需要开启本地服务，从性能方面考虑也是不合适。第二种方式存在的缺陷很多，一来只能播放网络上返回格式contentType为public/mpeg4等视频格式的url视频地址，若保存下来之后，文件的格式也需要保存为.mp4或.mov等格式的本地文件才能从本地中读取，三来使用AVMutableComposition对视频进行重构后保存，经过检验会对视频源数据产生变化，对于程序开发人员来说，需要保证各端存在的视频数据一致。第三种边下边播的方法其实是对第二种方法的扩展，能够解决上面所说的三种问题，可操控的自由度更高。</p>

      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/10/06/Video-streaming-and-caching-in-iOS/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/10/06/Video-streaming-and-caching-in-iOS/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/10/06/Video-streaming-and-caching-in-iOS/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-07-22T02:50:14.000Z"><a href="/2015/07/22/总结一些有用的iOS工具/">周三, 7月 22 2015, 10:50:14 上午</a></time>

  
    <h1 class="title"><a href="/2015/07/22/总结一些有用的iOS工具/">总结一些有用的iOS工具</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p><a href="http://fuckingclangwarnings.com/" target="_blank" rel="noopener">《Which Clang Warning Is Generating This Message》</a>：Clang 的警告与语义对照表。通过它可以更加方便地知道 Clang 的警告所表达的意思。</p>
<p><a href="http://swiftdoc.org/" target="_blank" rel="noopener">SwiftDoc</a>：SwiftDoc是一个在线的Swift帮助文档。</p>
<p><a href="http://neilpa.me/rac-marbles/#merge" target="_blank" rel="noopener">RAC函数使用交互图</a>：列出Reactive Cocoa中常用函数的交互图</p>
<p><a href="http://www.osstatus.com" target="_blank" rel="noopener">OSStatus</a> 苹果底层错误码原因查询</p>
<p><a href="https://www.hex-rays.com/products/ida/index.shtml" target="_blank" rel="noopener">IDA</a> 支持Win、Linux、Mac OS的多平台反汇编器，有免费试用版</p>
<p><a href="http://revealapp.com/" target="_blank" rel="noopener">Reveal</a> 能分析app UI布局，有点类似苹果自带的布局分析工具，但这个工具能够使用在逆向工程中帮助你分析界面层次，官网没有提供免费的版本，需自行寻找破解版本</p>
<p><a href="http://www.i-funbox.com/" target="_blank" rel="noopener">iFunBox</a> iOS文件管理工具，免费工具</p>
<p><a href="http://www.charlesproxy.com/" target="_blank" rel="noopener">Charles</a> 网络抓包分析修改工具,可免费可收费</p>
<p><a href="http://www.navicat.com/store/navicat-premium" target="_blank" rel="noopener">Navicat Premium</a> 数据库管理工具，官网收费，自行寻找破解版</p>
<p><a href="https://kapeli.com/dash" target="_blank" rel="noopener">Dash</a> 文档管理工具，免费，可下载所有语言文档</p>
<p><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">Source Tree</a> git管理工具，免费</p>
<p><a href="http://astah.net/editions/community" target="_blank" rel="noopener">astah community</a> 绘制UML图</p>
<p>[class-dump] iOS逆向中用于导出Mach-O文件的头部信息</p>
<p>持续更新…</p>

      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/07/22/总结一些有用的iOS工具/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/07/22/总结一些有用的iOS工具/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/07/22/总结一些有用的iOS工具/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-14T06:58:20.000Z"><a href="/2015/06/14/Dynamic-Library-Usage-Guidelines/">周日, 6月 14 2015, 2:58:20 下午</a></time>

  
    <h1 class="title"><a href="/2015/06/14/Dynamic-Library-Usage-Guidelines/">Dynamic Library Usage Guidelines</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        间接寻址是一种代码生成技术的名字，它允许被定义在文件中的symbols能够被另外一个文件引用，并且不需要引用文件知道任何有关定义这些symbol文件的布局。因此，定义文件能够被独立地修改。间接寻址最小化了动态链接器需要修改的地址，这回提高代码分享和提高效率......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/14/Dynamic-Library-Usage-Guidelines/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/14/Dynamic-Library-Usage-Guidelines/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/14/Dynamic-Library-Usage-Guidelines/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-11T09:31:02.000Z"><a href="/2015/06/11/Overview-of-Dynamic-Libraries/">周四, 6月 11 2015, 5:31:02 下午</a></time>

  
    <h1 class="title"><a href="/2015/06/11/Overview-of-Dynamic-Libraries/">Overview of Dynamic Libraries</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        决定app性能的两个重要因素是他们的启动时间和他们的内存跟踪。当程序运行时减少一个app的执行的文件的大小和最少化它内存的使用率会使app更快地启动并且使用更少的内存。使用动态库来代替静态库回减少一个app执行文件的大小。他们同样也能让app去在加载库被需要时才加载库的特定功能，而不是在他们启动的时候就被加载。这个特性能够减少启动时间和让内存更有效地利用......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/11/Overview-of-Dynamic-Libraries/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/11/Overview-of-Dynamic-Libraries/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/11/Overview-of-Dynamic-Libraries/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-10T07:54:40.000Z"><a href="/2015/06/10/position-independent-code/">周三, 6月 10 2015, 3:54:40 下午</a></time>

  
    <h1 class="title"><a href="/2015/06/10/position-independent-code/">位置独立代码</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        位置独立代码（Position-independent code)，是在PowerPC环境代码生成技术的名字，它允许动态链接器在不固定的虚拟内存地址中加载一个区域代码。除了位置独立代码生成的一些形式之外，操作系统会把你希望共享的代码放置在虚拟内存固定地址中，这会导致维护操作系统时相当困难。例如，它基本不会支持shared libraries和frameworks，因为他们都需要预先分配一个永远不会变的地址......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/10/position-independent-code/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/10/position-independent-code/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/10/position-independent-code/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-10T07:54:28.000Z"><a href="/2015/06/10/indirect-addressing/">周三, 6月 10 2015, 3:54:28 下午</a></time>

  
    <h1 class="title"><a href="/2015/06/10/indirect-addressing/">间接寻址</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        间接寻址是一种代码生成技术的名字，它允许被定义在文件中的symbols能够被另外一个文件引用，并且不需要引用文件知道任何有关定义这些symbol文件的布局。因此，定义文件能够被独立地修改。间接寻址最小化了动态链接器需要修改的地址，这会提高代码分享和提高效率......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/10/indirect-addressing/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/10/indirect-addressing/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/10/indirect-addressing/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-07T03:03:15.000Z"><a href="/2015/06/07/loading-code_at-runtime/">周日, 6月 7 2015, 11:03:15 上午</a></time>

  
    <h1 class="title"><a href="/2015/06/07/loading-code_at-runtime/">在运行时加载代码</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        你可能需要用到动态分享库，它能够保存可重用代码，在多个程序使用时有函数的使用优势。例如，当你开发Cocoa应用程序时，你的程序最少会链接Foudation和Application Kit框架。通过这个实践，当你的应用程序用户更新电脑系统软件框架时，你的程序能够自动利用那些改进的框架......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/07/loading-code_at-runtime/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/07/loading-code_at-runtime/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/07/loading-code_at-runtime/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-07T00:47:09.000Z"><a href="/2015/06/07/executing-mach-o-file/">周日, 6月 7 2015, 8:47:09 早上</a></time>

  
    <h1 class="title"><a href="/2015/06/07/executing-mach-o-file/">运行Mach-O文件</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        为了展示代码的效果，程序必须启动线程和链接到dynamic shared libraries（动态分享库），为了与其它库和模块一起运行，你的应用程序必须在modules(.o)里面定义符号的引用，这些引用会在运行时被解决。在运行时应用程序中所有modules的symbol名字都会在共享的命名空间中使用。为了允许未来应用程序和使用库的使用，应用程序和库的开发者必须保证他们在功能和数据中选择的名字不会与其它modules冲突......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/07/executing-mach-o-file/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/07/executing-mach-o-file/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/07/executing-mach-o-file/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-05T10:37:57.000Z"><a href="/2015/06/05/executable_mach_o_file/">周五, 6月 5 2015, 6:37:57 晚上</a></time>

  
    <h1 class="title"><a href="/2015/06/05/executable_mach_o_file/">可执行文件Mach-O的结构</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        在Mach-O文件的开头，有一个header结构标记这个文件的类型为Mach-O文件，并且这个结构里面包含了一些其它的信息：如target architecture和其它文件解析的选项等......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/05/executable_mach_o_file/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/05/executable_mach_o_file/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/05/executable_mach_o_file/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一页<i class="fa fa-long-arrow-right"></i></a>
  
  <div class="clearfix"></div>
</nav>

<script src="/js/jquery.anystretch.min.js"></script>
<script src="/js/cover.js"></script>

    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div>
  
  &copy; 2019 Weihao Xu
  
</div>
Powered by <a href="http://zespia.tw/hexo/" title="Hexo" target="_blank" rel="noopener">Hexo</a> and <a href="http://pages.github.com/" title="GitHub Pages" target="_blank" rel="noopener">GitHub Pages</a>

<div class="clearfix"></div></footer>
  
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js"></script>




    <script type="text/javascript">
        (function(){
                    $("#main-nav").removeClass('normal_mode').addClass('top_mode');
/*
            $(window).scroll(function(){

                var scrollTop = $(window).scrollTop();
                if ( scrollTop > 0 ){
                    $("#main-nav").removeClass('normal_mode').addClass('top_mode');
                } else{
                    $("#main-nav").removeClass('top_mode').addClass('normal_mode');
                }

            });
*/
        })();
    </script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
  (function($){
    $('.fancybox').fancybox({
      'titlePosition': 'inside'
    });
  })(jQuery);
  </script>



    
    <script type="text/javascript">
      var duoshuoQuery = {short_name:"sky-weihao"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = 'http://static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] 
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>



<script type="text/javascript">
  
  $(function(){

    $('.title').hover(
      function() {      
        $(this).stop().animate(
          {'marginLeft': '10px'}, 200
        );   
      }, 
      function() {       
        $(this).stop().animate({'marginLeft': '0px'}, 200);      
      
    });   

  });

</script>


</body>
</html>