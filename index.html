<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Sky-Weihao的博客</title>
  <meta name="author" content="Weihao Xu">
  
  <meta name="description" content="欢迎光临寒舍">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Sky-Weihao的博客"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/avatar.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Sky-Weihao的博客" type="application/atom+xml">
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-368771XX-X']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>

<body>
  <header id="header" class='normal_mode'>
    <nav id="main-nav">
  <ul class='container'>
    
  </ul>
  <div class="clearfix"></div>
</nav>
  </header>
  <div id="content" class="container">
    <div id="cover">
	<div id="profile" alt="http://sky-weihao.github.io/img/background.jpg">
		<a href="/">
			<div class="logo">
				<img src="/avatar.png" alt="Profile Picture">
			</div>
			<div id="title">Sky-Weihao的博客</div>
		</a>

		
			<div id="subtitle">欢迎光临寒舍</div>
		
		 <ul class="my-socials">
  
  <li>
  	<a href="https://github.com/sky-weihao" class="github" target="_blank">
  		<i class="fa fa-github"></i>
  	</a>
  </li>
  
  <li>
  	<a href="http://weibo.com/1867935643/profile" class="weibo" target="_blank">
  		<i class="fa fa-weibo"></i>
  	</a>
  </li>
  
 
 <li>
   	<a href="mailto:110458260@qq.com" class="email" target="_blank" title="Email Me">
  		<i class="fa fa-envelope"></i>
  	</a>
 </li>
 
</ul>
	</div>
</div>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-10-06T02:49:41.000Z"><a href="/2015/10/06/Video-streaming-and-caching-in-iOS/">周二, 10月 6 2015, 10:49:41 上午</a></time>

  
    <h1 class="title"><a href="/2015/10/06/Video-streaming-and-caching-in-iOS/">iOS音视频实现边下载边播放</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，原创博客/">博客，原创博客</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>近段时间制作视频播放社区的功能，期间查找了不少资料，做过很多尝试，现在来整理一下其中遇到的一些坑.由于考虑到AVPlayer对视频有更高自由度的控制，而且能够使用它自定义视频播放界面，iOS中所使用的视频播放控件为AVPlayer，而抛弃了高层次的MediaPlayer框架，现在想想挺庆幸当初使用了AVPlayer。</p>
<h3 id="AVPlayer的基本知识">AVPlayer的基本知识</h3><p>AVPlayer本身并不能显示视频，而且它也不像MPMoviePlayerController有一个view属性。如果AVPlayer要显示必须创建一个播放器层AVPlayerLayer用于展示，播放器层继承于CALayer，有了AVPlayerLayer之添加到控制器视图的layer中即可。要使用AVPlayer首先了解一下几个常用的类：</p>
<p>AVAsset：主要用于获取多媒体信息，是一个抽象类，不能直接使用。</p>
<p>AVURLAsset：AVAsset的子类，可以根据一个URL路径创建一个包含媒体信息的AVURLAsset对象。</p>
<p>AVPlayerItem：一个媒体资源管理对象，管理者视频的一些基本信息和状态，一个AVPlayerItem对应着一个视频资源。</p>
<h3 id="iOS视频实现边下载边播放的几种实现">iOS视频实现边下载边播放的几种实现</h3><h4 id="1-本地实现http_server">1.本地实现http server</h4><p>在iOS本地开启Local Server服务，然后使用播放控件请求本地Local Server服务，本地的服务再不断请求视频地址获取视频流，本地服务请求的过程中把视频缓存到本地，这种方法在网上有很多<a href="http://code4app.com/ios/%E8%A7%86%E9%A2%91%E8%BE%B9%E4%B8%8B%E8%BD%BD%E8%BE%B9%E6%92%AD%E6%94%BE/5292c381cb7e8445678b5ac2#" target="_blank" rel="external">例子</a>，有兴趣了解的人可自己下载例子查看。</p>
<h4 id="2-使用AVPlayer的方法开启下载服务">2.使用AVPlayer的方法开启下载服务</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">AVURLAsset</span> *urlAsset = [[<span class="built_in">AVURLAsset</span> alloc]initWithURL:url options:<span class="literal">nil</span>];</span><br><span class="line"><span class="number">2.</span><span class="built_in">AVPlayerItem</span> *item = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:urlAsset];</span><br><span class="line"><span class="number">3.</span>[<span class="keyword">self</span><span class="variable">.avPlayer</span> replaceCurrentItemWithPlayerItem:item];</span><br><span class="line"><span class="number">4.</span>[<span class="keyword">self</span> addObserverToPlayerItem:item];</span><br></pre></td></tr></table></figure>
<p>但由于AVPlayer是没有提供方法给我们直接获取它下载下来的数据，所以我们只能在视频下载完之后自己去寻找缓存视频数据的办法，AVFoundation框架中有一种从多媒体信息类AVAsset中提取视频数据的类AVMutableComposition和AVAssetExportSession。<br>其中AVMutableComposition的作用是能够从现有的asset实例中创建出一个新的AVComposition(它也是AVAsset的字类)，使用者能够从别的asset中提取他们的音频轨道或视频轨道，并且把它们添加到新建的Composition中。<br>AVAssetExportSession的作用是把现有的自己创建的asset输出到本地文件中。<br>为什么需要把原先的AVAsset(AVURLAsset)实现的数据提取出来后拼接成另一个AVAsset(AVComposition)的数据后输出呢，由于通过网络url下载下来的视频没有保存视频的原始数据（或者苹果没有暴露接口给我们获取），下载后播放的avasset不能使用AVAssetExportSession输出到本地文件，要曲线地把下载下来的视频通过重构成另外一个AVAsset实例才能输出。代码例子如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *documentDirectory = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">NSString</span> *myPathDocument = [documentDirectory stringByAppendingPathComponent:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.mp4"</span>,[_source<span class="variable">.videoUrl</span> MD5]]];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURL</span> *fileUrl = [<span class="built_in">NSURL</span> fileURLWithPath:myPathDocument];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asset != <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="built_in">AVMutableComposition</span> *mixComposition = [[<span class="built_in">AVMutableComposition</span> alloc]init];</span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *firstTrack = [mixComposition addMutableTrackWithMediaType:<span class="built_in">AVMediaTypeVideo</span> preferredTrackID:kC<span class="built_in">MPersistentTrackID_Invalid</span>];</span><br><span class="line">[firstTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, asset<span class="variable">.duration</span>) ofTrack:[[asset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>]objectAtIndex:<span class="number">0</span>] atTime:kCMTimeZero error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *audioTrack = [mixComposition addMutableTrackWithMediaType:<span class="built_in">AVMediaTypeAudio</span> preferredTrackID:kC<span class="built_in">MPersistentTrackID_Invalid</span>];</span><br><span class="line">[audioTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, asset<span class="variable">.duration</span>) ofTrack:[[asset tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>]objectAtIndex:<span class="number">0</span>] atTime:kCMTimeZero error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVAssetExportSession</span> *exporter = [[<span class="built_in">AVAssetExportSession</span> alloc]initWithAsset:mixComposition presetName:<span class="built_in">AVAssetExportPresetHighestQuality</span>];</span><br><span class="line">exporter<span class="variable">.outputURL</span> = fileUrl;</span><br><span class="line"><span class="keyword">if</span> (exporter<span class="variable">.supportedFileTypes</span>) &#123;</span><br><span class="line">exporter<span class="variable">.outputFileType</span> = [exporter<span class="variable">.supportedFileTypes</span> objectAtIndex:<span class="number">0</span>] ;</span><br><span class="line">exporter<span class="variable">.shouldOptimizeForNetworkUse</span> = <span class="literal">YES</span>;</span><br><span class="line">[exporter exportAsynchronouslyWithCompletionHandler:^&#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-使用AVAssetResourceLoader回调下载，也是最终决定使用的技术">3.使用AVAssetResourceLoader回调下载，也是最终决定使用的技术</h3><p>AVAssetResourceLoader通过你提供的委托对象去调节AVURLAsset所需要的加载资源。<strong>而很重要的一点是，AVAssetResourceLoader仅在AVURLAsset不知道如何去加载这个URL资源时才会被调用，就是说你提供的委托对象在AVURLAsset不知道如何加载资源时才会得到调用</strong>。所以我们又要通过一些方法来曲线解决这个问题，把我们目标视频URL地址的scheme替换为系统不能识别的scheme，然后在我们调用网络请求去处理这个URL时把scheme切换为原来的scheme。</p>
<p>实现边下边播功能AVResourceLoader的委托对象必须要实现AVAssetResourceLoaderDelegate下五个协议的其中两个：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="comment">//在系统不知道如何处理URLAsset资源时回调</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_9, <span class="number">6</span>_0);</span><br><span class="line"><span class="number">2</span><span class="comment">//在取消加载资源后回调</span></span><br><span class="line">- (<span class="keyword">void</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader didCancelLoadingRequest:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_9, <span class="number">7</span>_0);</span><br></pre></td></tr></table></figure>
<p>以下来说说具体要怎么做处理</p>
<h4 id="第一步，创建一个AVURLAsset，并且用它来初始化一个AVPlayerItem">第一步，创建一个AVURLAsset，并且用它来初始化一个AVPlayerItem</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#define kCustomVideoScheme @<span class="title">"yourScheme"</span></span></span><br><span class="line"><span class="built_in">NSURL</span> *currentURL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://***.***.***"</span>];</span><br><span class="line"><span class="built_in">NSURLComponents</span> *components = [[<span class="built_in">NSURLComponents</span> alloc]initWithURL:currentURL resolvingAgainstBaseURL:<span class="literal">NO</span>];</span><br><span class="line"><span class="number">1</span><span class="comment">////注意，不加这一句不能执行到回调操作</span></span><br><span class="line">components<span class="variable">.scheme</span> = kCustomVideoScheme;</span><br><span class="line"><span class="built_in">AVURLAsset</span> *urlAsset = [<span class="built_in">AVURLAsset</span> URLAssetWithURL:components<span class="variable">.URL</span>  </span><br><span class="line">options:<span class="literal">nil</span>];</span><br><span class="line"><span class="number">2</span><span class="comment">//_resourceManager在接下来讲述</span></span><br><span class="line">[urlAsset<span class="variable">.resourceLoader</span> setDelegate:_resourceManager queue:dispatch_get_main_queue()];</span><br><span class="line"><span class="built_in">AVPlayerItem</span> *item = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:urlAsset];</span><br><span class="line">_playerItem = item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IOS9_OR_LATER) &#123;</span><br><span class="line">item<span class="variable">.canUseNetworkResourcesForLiveStreamingWhilePaused</span> = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.avPlayer</span> replaceCurrentItemWithPlayerItem:item];</span><br><span class="line"><span class="keyword">self</span><span class="variable">.playerLayer</span><span class="variable">.player</span> = <span class="keyword">self</span><span class="variable">.avPlayer</span>;</span><br><span class="line">[<span class="keyword">self</span> addObserverToPlayerItem:item];**</span><br></pre></td></tr></table></figure>
<h4 id="第二步，创建AVResourceManager实现AVResourceLoader协议">第二步，创建AVResourceManager实现AVResourceLoader协议</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> <span class="string">AVAResourceLoaderManager :</span> NSObject &lt; AVAssetResourceLoaderDelegate &gt;</span><br></pre></td></tr></table></figure>
<h4 id="第三步，实现两个必须的回调协议，实现中有几件需要做的事情">第三步，实现两个必须的回调协议，实现中有几件需要做的事情</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">1</span><span class="comment">//获取系统中不能处理的URL</span></span><br><span class="line"><span class="built_in">NSURL</span> *resourceURL = [loadingRequest<span class="variable">.request</span> URL];</span><br><span class="line"><span class="number">2</span><span class="comment">//判断这个URL是否遵守URL规范和其是否是我们所设定的URL</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> checkIsLegalURL:resourceURL] &amp;&amp; [resourceURL<span class="variable">.scheme</span> isEqualToString:kCustomVideoScheme])&#123;</span><br><span class="line"><span class="number">3</span><span class="comment">//判断当前的URL网络请求是否已经被加载过了，如果缓存中里面有URL对应的网络加载器(自己封装，也可以直接使用NSURLRequest)，则取出来添加请求，每一个URL对应一个网络加载器，loader的实现接下来会说明</span></span><br><span class="line"><span class="built_in">AVResourceLoaderForASI</span> *loader = [<span class="keyword">self</span> asiresourceLoaderForRequest:loadingRequest];</span><br><span class="line"><span class="keyword">if</span> (loader == <span class="literal">nil</span>)&#123;</span><br><span class="line">loader = [[<span class="built_in">AVResourceLoaderForASI</span> alloc] initWithResourceURL:resourceURL];</span><br><span class="line">loader<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line"><span class="number">4</span><span class="comment">//缓存网络加载器</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.resourceLoaders</span> setObject:loader forKey:[<span class="keyword">self</span> keyForResourceLoaderWithURL:resourceURL]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span><span class="comment">//加载器添加请求</span></span><br><span class="line">[loader addRequest:loadingRequest];</span><br><span class="line"><span class="number">6</span><span class="comment">//返回YES则表明使用我们的代码对AVAsset中请求网络资源做处理</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader didCancelLoadingRequest:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果用户在下载的过程中调用者取消了获取视频,则从缓存中取消这个请求</span></span><br><span class="line"><span class="built_in">NSURL</span> *resourceURL = [loadingRequest<span class="variable">.request</span> URL];</span><br><span class="line"><span class="built_in">NSString</span> *actualURLString = [<span class="keyword">self</span> actualURLStringWithURL:resourceURL];</span><br><span class="line"><span class="built_in">AVResourceLoaderForASI</span> *loader = [_resourceLoaders objectForKey:actualURLString];</span><br><span class="line">[loader removeRequest:loadingRequest];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第四步，判断缓存中是否已下载完视频">第四步，判断缓存中是否已下载完视频</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addRequest:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1判断自身是否已经取消加载</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">self</span><span class="variable">.isCancelled</span>==<span class="literal">NO</span>)&#123;</span><br><span class="line"><span class="comment">//2判断本地中是否已经有文件的缓存，如果有，则直接从缓存中读取数据，文件保存和读取这里不做详述，使用者可根据自身情况创建文件系统</span></span><br><span class="line"><span class="built_in">AVAResourceFile</span> *resourceFile = [<span class="keyword">self</span><span class="variable">.resourceFileManager</span> resourceFileWithURL:<span class="keyword">self</span><span class="variable">.resourceURL</span>];</span><br><span class="line"><span class="keyword">if</span> (resourceFile) &#123;</span><br><span class="line"><span class="comment">//3若本地文件存在，则从文件中获取以下属性  </span></span><br><span class="line">loadingRequest<span class="variable">.contentInformationRequest</span><span class="variable">.byteRangeAccessSupported</span> = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">//3.1contentType</span></span><br><span class="line">loadingRequest<span class="variable">.contentInformationRequest</span><span class="variable">.contentType</span> = resourceFile<span class="variable">.contentType</span>;</span><br><span class="line"><span class="comment">//3.2数据长度          		  </span></span><br><span class="line">loadingRequest<span class="variable">.contentInformationRequest</span><span class="variable">.contentLength</span> = resourceFile<span class="variable">.contentLength</span>;</span><br><span class="line"><span class="comment">//3.3请求的偏移量</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> requestedOffset = loadingRequest<span class="variable">.dataRequest</span><span class="variable">.requestedOffset</span>;</span><br><span class="line"><span class="comment">//3.4请求总长度</span></span><br><span class="line"><span class="built_in">NSInteger</span> requestedLength = loadingRequest<span class="variable">.dataRequest</span><span class="variable">.requestedLength</span>;</span><br><span class="line"><span class="comment">//3.5取出本地文件中从偏移量到请求长度的数据</span></span><br><span class="line"><span class="built_in">NSData</span> *subData = [resourceFile<span class="variable">.data</span> subdataWithRange:<span class="built_in">NSMakeRange</span>(@(requestedOffset)<span class="variable">.unsignedIntegerValue</span>, requestedLength)];</span><br><span class="line"><span class="comment">//3.6返回数据给请求</span></span><br><span class="line">[loadingRequest<span class="variable">.dataRequest</span> respondWithData:subData];</span><br><span class="line">[loadingRequest finishLoading];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//4如果没有本地文件，则开启网络请求，从网络中获取 ,见第五步 </span></span><br><span class="line">[<span class="keyword">self</span> startWithRequest:loadingRequest];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//5如果已经取消请求，并且请求没有完成，则封装错误给请求，可自己实现</span></span><br><span class="line"><span class="keyword">if</span>(loadingRequest<span class="variable">.isFinished</span>==<span class="literal">NO</span>)&#123;</span><br><span class="line">[loadingRequest finishLoadingWithError:[<span class="keyword">self</span> loaderCancelledError]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第五步，添加loadingRequest到网络文件加载器，这部分的操作比较长">第五步，添加loadingRequest到网络文件加载器，这部分的操作比较长</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startWithRequest:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">1</span><span class="comment">//判断当前请求是否已经开启，由于苹果系统原因，会有两次回调到AVResourceLoaderDelegate，我们对其进行判断，只开启一次请求</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.dataTask</span> == <span class="literal">nil</span>)&#123;</span><br><span class="line"><span class="number">2</span><span class="comment">//根据loadingRequest中的URL创建NSURLRequest，注意在此把URL中的scheme修改为原先的scheme</span></span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="keyword">self</span> requestWithLoadingRequest:loadingRequest];</span><br><span class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="number">3</span><span class="comment">//获取url的绝对路径，并使用ASIHttpRequest进行网络请求，下面的请求方法经过封装，就不详说如何对ASI进行封装了，但是每一步需要做的事情能以block的形式更好说明</span></span><br><span class="line"><span class="built_in">NSString</span> *urlString = request<span class="variable">.URL</span><span class="variable">.absoluteString</span>;</span><br><span class="line"><span class="keyword">self</span><span class="variable">.dataTask</span> = [<span class="keyword">self</span> GET:urlString requestBlock:^(Request *req) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s %@ ###"</span>, __func__, req);</span><br><span class="line"><span class="number">4</span><span class="comment">//在接受到请求头部信息时，说明链接成功，数据开始传输</span></span><br><span class="line"><span class="keyword">if</span> (req<span class="variable">.recvingHeader</span><span class="comment">//意思是请求接受到头部信息状态)&#123;</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s recvingHeader ###"</span>, __func__);</span><br><span class="line">__<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"><span class="keyword">if</span> ([urlString isEqualToString:req<span class="variable">.originalURL</span><span class="variable">.absoluteString</span>]) &#123;</span><br><span class="line"><span class="number">4.1</span><span class="comment">//，创建临时数据保存网络下载下来的视频信息</span></span><br><span class="line">strongSelf<span class="variable">.tempData</span> = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4.2</span><span class="comment">//把头部信息内容写入到AVAssetResourceLoadingRequest，即loadingRequest中</span></span><br><span class="line">[strongSelf processPendingRequests];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (req<span class="variable">.recving</span><span class="comment">//请求接受中状态)&#123;</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s recving ###"</span>, __func__);</span><br><span class="line">__<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"><span class="number">5</span><span class="comment">//此处需多次调用把请求的信息写入到loadingRequest的步骤，实现下载的过程中数据能输出到loadingRequest播放</span></span><br><span class="line"><span class="keyword">if</span> (urlString == req<span class="variable">.originalURL</span><span class="variable">.absoluteString</span>) &#123;</span><br><span class="line"><span class="number">5.1</span><span class="comment">//这个处理是判断此时返回的头部信息是重定向还是实际视频的头部信息，如果是重定向信息，则不作处理</span></span><br><span class="line"><span class="keyword">if</span> (!_contentInformation &amp;&amp; req<span class="variable">.responseHeaders</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ([req<span class="variable">.responseHeaders</span> objectForKey:<span class="string">@"Location"</span>] ) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@" ### %s redirection URL ###"</span>, __func__);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//5.2如果不是重定向信息，则把需要用到的信息提取出来</span></span><br><span class="line">_contentInformation = [[RLContentInformationForASI alloc]init];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> numer = [[req<span class="variable">.responseHeaders</span> objectForKey:<span class="string">@"Content-Length"</span>]longLongValue];</span><br><span class="line">_contentInformation<span class="variable">.contentLength</span> = numer;</span><br><span class="line">_contentInformation<span class="variable">.byteRangeAccessSupported</span> = <span class="literal">YES</span>;</span><br><span class="line">_contentInformation<span class="variable">.contentType</span> = [req<span class="variable">.responseHeaders</span> objectForKey:<span class="string">@"Content-type"</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.3开始从请求中获取返回数据</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s before tempData length = %lu ###"</span>, __FUNCTION__, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span><span class="variable">.tempData</span><span class="variable">.length</span>);</span><br><span class="line">strongSelf<span class="variable">.tempData</span> = [<span class="built_in">NSMutableData</span> dataWithData:req<span class="variable">.rawResponseData</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s after tempData length = %lu ###"</span>,__FUNCTION__, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span><span class="variable">.tempData</span><span class="variable">.length</span>);</span><br><span class="line"><span class="comment">//5.4把返回数据输出到loadingRequest中</span></span><br><span class="line">[strongSelf processPendingRequests];</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (req<span class="variable">.succeed</span>)&#123;</span><br><span class="line"><span class="number">6</span><span class="comment">//请求返回成功，在这里做最后一次把数据输出到loadingRequest，且做一些成功后的事情</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s succeed ###"</span>, __func__);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s tempData length = %lu ###"</span>, __func__, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span><span class="variable">.tempData</span><span class="variable">.length</span>);</span><br><span class="line">__<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"><span class="keyword">if</span> (strongSelf) &#123;</span><br><span class="line">[strongSelf processPendingRequests];</span><br><span class="line"></span><br><span class="line"><span class="number">7</span><span class="comment">//保存缓存文件，我在保存文件这里做了一次偷懒，如果有人参考我写的文件可对保存文件作改进，在每次返回数据时把数据追加写到文件，而不是下载成功之后才保存，这请求时也可以使用这个来实现断点重输的功能</span></span><br><span class="line"><span class="built_in">AVAResourceFile</span> *resourceFile = [[<span class="built_in">AVAResourceFile</span> alloc]initWithContentType:strongSelf<span class="variable">.contentInformation</span><span class="variable">.contentType</span> date:strongSelf<span class="variable">.tempData</span>];</span><br><span class="line">[strongSelf<span class="variable">.resourceFileManager</span> saveResourceFile:resourceFile withURL:<span class="keyword">self</span><span class="variable">.resourceURL</span>];</span><br><span class="line"><span class="number">8</span><span class="comment">//在此做一些清理缓存、释放对象和回调到上层的操作</span></span><br><span class="line">[strongSelf complete];</span><br><span class="line"><span class="keyword">if</span> (strongSelf<span class="variable">.delegate</span> &amp;&amp; [strongSelf<span class="variable">.delegate</span> respondsToSelector:<span class="keyword">@selector</span>(resourceLoader:didLoadResource:)]) &#123;</span><br><span class="line">[strongSelf<span class="variable">.delegate</span> resourceLoader:strongSelf didLoadResource:strongSelf<span class="variable">.resourceURL</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (req<span class="variable">.failed</span>)&#123;</span><br><span class="line"><span class="comment">//9如果请求返回失败，则向上层抛出错误，且清理缓存等操作</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s failed ###"</span> , __func__);</span><br><span class="line">[<span class="keyword">self</span> completeWithError:req<span class="variable">.error</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.pendingRequests</span> addObject:loadingRequest];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第六步，把请求返回数据输出到loadingRequest的操作">第六步，把请求返回数据输出到loadingRequest的操作</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)processPendingRequests</span><br><span class="line">&#123;</span><br><span class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">__<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *requestsCompleted = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="number">1</span><span class="comment">//从缓存信息中找出当前正在请求中的loadingRequest</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">AVAssetResourceLoadingRequest</span> *loadingRequest <span class="keyword">in</span> strongSelf<span class="variable">.pendingRequests</span>)&#123;</span><br><span class="line"><span class="number">2</span><span class="comment">//把头部信息输出到loadingRequest中</span></span><br><span class="line">[strongSelf fillInContentInformation:loadingRequest<span class="variable">.contentInformationRequest</span>];      </span><br><span class="line"><span class="number">3</span><span class="comment">//把视频数据输出到loadingRequest中</span></span><br><span class="line"><span class="built_in">BOOL</span> didRespondCompletely = [strongSelf respondWithDataForRequest:loadingRequest<span class="variable">.dataRequest</span>];</span><br><span class="line"><span class="number">4</span><span class="comment">//在success状态中做最后一次调用的时候，检测到请求已经完成，则从缓存信息中清除loadingRequest，并且把loadingRequest标志为完成处理状态</span></span><br><span class="line"><span class="keyword">if</span> (didRespondCompletely)&#123;</span><br><span class="line">[requestsCompleted addObject:loadingRequest];</span><br><span class="line">[loadingRequest finishLoading];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span><span class="comment">//清理缓存</span></span><br><span class="line">[strongSelf<span class="variable">.pendingRequests</span> removeObjectsInArray:requestsCompleted];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">、</span><br><span class="line"></span><br><span class="line"><span class="comment">//把提取出来的头部信息输出到loadingRequest中，可以优化</span></span><br><span class="line">- (<span class="keyword">void</span>)fillInContentInformation:(<span class="built_in">AVAssetResourceLoadingContentInformationRequest</span> *)contentInformationRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (contentInformationRequest == <span class="literal">nil</span> || <span class="keyword">self</span><span class="variable">.contentInformation</span> == <span class="literal">nil</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">contentInformationRequest<span class="variable">.byteRangeAccessSupported</span> = <span class="keyword">self</span><span class="variable">.contentInformation</span><span class="variable">.byteRangeAccessSupported</span>;</span><br><span class="line">contentInformationRequest<span class="variable">.contentType</span> = <span class="keyword">self</span><span class="variable">.contentInformation</span><span class="variable">.contentType</span>;</span><br><span class="line">contentInformationRequest<span class="variable">.contentLength</span> = <span class="keyword">self</span><span class="variable">.contentInformation</span><span class="variable">.contentLength</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把缓存数据输出到loadingRequest中</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)respondWithDataForRequest:(<span class="built_in">AVAssetResourceLoadingDataRequest</span> *)dataRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> startOffset = dataRequest<span class="variable">.requestedOffset</span>;</span><br><span class="line"><span class="keyword">if</span> (dataRequest<span class="variable">.currentOffset</span> != <span class="number">0</span>)&#123;</span><br><span class="line">startOffset = dataRequest<span class="variable">.currentOffset</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don't have any data at all for this request</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.tempData</span><span class="variable">.length</span> &lt; startOffset)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is the total data we have from startOffset to whatever has been downloaded so far</span></span><br><span class="line"><span class="built_in">NSUInteger</span> unreadBytes = <span class="keyword">self</span><span class="variable">.tempData</span><span class="variable">.length</span> - (<span class="built_in">NSUInteger</span>)startOffset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Respond with whatever is available if we can't satisfy the request fully yet</span></span><br><span class="line"><span class="built_in">NSUInteger</span> numberOfBytesToRespondWith = MIN((<span class="built_in">NSUInteger</span>)dataRequest<span class="variable">.requestedLength</span>, unreadBytes);</span><br><span class="line"></span><br><span class="line">[dataRequest respondWithData:[<span class="keyword">self</span><span class="variable">.tempData</span> subdataWithRange:<span class="built_in">NSMakeRange</span>((<span class="built_in">NSUInteger</span>)startOffset, numberOfBytesToRespondWith)]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> endOffset = startOffset + dataRequest<span class="variable">.requestedLength</span>;</span><br><span class="line"><span class="built_in">BOOL</span> didRespondFully = <span class="keyword">self</span><span class="variable">.tempData</span><span class="variable">.length</span> &gt;= endOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> didRespondFully;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>视频边下边播的流程大致上已经描述完毕，本博文中没有说到的代码有错误处理方式、缓存文件的读写和保存格式、部分内存缓存使用说明、</strong></p>
<p>参考链接：<br><a href="http://www.codeproject.com/Articles/875105/Audio-streaming-and-caching-in-iOS-using" target="_blank" rel="external">http://www.codeproject.com/Articles/875105/Audio-streaming-and-caching-in-iOS-using</a><br><a href="http://www.cnblogs.com/kenshincui/p/4186022.html#mpMoviePlayerController" target="_blank" rel="external">http://www.cnblogs.com/kenshincui/p/4186022.html#mpMoviePlayerController</a></p>

      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/10/06/Video-streaming-and-caching-in-iOS/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/10/06/Video-streaming-and-caching-in-iOS/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/10/06/Video-streaming-and-caching-in-iOS/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-07-22T02:50:14.000Z"><a href="/2015/07/22/总结一些有用的iOS工具/">周三, 7月 22 2015, 10:50:14 上午</a></time>

  
    <h1 class="title"><a href="/2015/07/22/总结一些有用的iOS工具/">总结一些有用的iOS工具</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p><a href="http://fuckingclangwarnings.com/" target="_blank" rel="external">《Which Clang Warning Is Generating This Message》</a>：Clang 的警告与语义对照表。通过它可以更加方便地知道 Clang 的警告所表达的意思。</p>
<p><a href="http://swiftdoc.org/" target="_blank" rel="external">SwiftDoc</a>：SwiftDoc是一个在线的Swift帮助文档。</p>
<p><a href="http://neilpa.me/rac-marbles/#merge" target="_blank" rel="external">RAC函数使用交互图</a>：列出Reactive Cocoa中常用函数的交互图</p>
<p><a href="http://www.osstatus.com" target="_blank" rel="external">OSStatus</a> 苹果底层错误码原因查询</p>
<p><a href="https://www.hex-rays.com/products/ida/index.shtml" target="_blank" rel="external">IDA</a> 支持Win、Linux、Mac OS的多平台反汇编器，有免费试用版</p>
<p><a href="http://revealapp.com/" target="_blank" rel="external">Reveal</a> 能分析app UI布局，有点类似苹果自带的布局分析工具，但这个工具能够使用在逆向工程中帮助你分析界面层次，官网没有提供免费的版本，需自行寻找破解版本</p>
<p><a href="http://www.i-funbox.com/" target="_blank" rel="external">iFunBox</a> iOS文件管理工具，免费工具</p>
<p><a href="http://www.charlesproxy.com/" target="_blank" rel="external">Charles</a> 网络抓包分析修改工具,可免费可收费</p>
<p><a href="http://www.navicat.com/store/navicat-premium" target="_blank" rel="external">Navicat Premium</a> 数据库管理工具，官网收费，自行寻找破解版</p>
<p><a href="https://kapeli.com/dash" target="_blank" rel="external">Dash</a> 文档管理工具，免费，可下载所有语言文档</p>
<p><a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">Source Tree</a> git管理工具，免费</p>
<p><a href="http://astah.net/editions/community" target="_blank" rel="external">astah community</a> 绘制UML图</p>
<p>[class-dump] iOS逆向中用于导出Mach-O文件的头部信息</p>
<p>持续更新…</p>

      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/07/22/总结一些有用的iOS工具/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/07/22/总结一些有用的iOS工具/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/07/22/总结一些有用的iOS工具/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-14T06:58:20.000Z"><a href="/2015/06/14/Dynamic-Library-Usage-Guidelines/">周日, 6月 14 2015, 2:58:20 下午</a></time>

  
    <h1 class="title"><a href="/2015/06/14/Dynamic-Library-Usage-Guidelines/">Dynamic Library Usage Guidelines</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        间接寻址是一种代码生成技术的名字，它允许被定义在文件中的symbols能够被另外一个文件引用，并且不需要引用文件知道任何有关定义这些symbol文件的布局。因此，定义文件能够被独立地修改。间接寻址最小化了动态链接器需要修改的地址，这回提高代码分享和提高效率......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/14/Dynamic-Library-Usage-Guidelines/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/14/Dynamic-Library-Usage-Guidelines/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/14/Dynamic-Library-Usage-Guidelines/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-11T09:31:02.000Z"><a href="/2015/06/11/Overview-of-Dynamic-Libraries/">周四, 6月 11 2015, 5:31:02 下午</a></time>

  
    <h1 class="title"><a href="/2015/06/11/Overview-of-Dynamic-Libraries/">Overview of Dynamic Libraries</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        决定app性能的两个重要因素是他们的启动时间和他们的内存跟踪。当程序运行时减少一个app的执行的文件的大小和最少化它内存的使用率会使app更快地启动并且使用更少的内存。使用动态库来代替静态库回减少一个app执行文件的大小。他们同样也能让app去在加载库被需要时才加载库的特定功能，而不是在他们启动的时候就被加载。这个特性能够减少启动时间和让内存更有效地利用......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/11/Overview-of-Dynamic-Libraries/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/11/Overview-of-Dynamic-Libraries/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/11/Overview-of-Dynamic-Libraries/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-10T07:54:40.000Z"><a href="/2015/06/10/position-independent-code/">周三, 6月 10 2015, 3:54:40 下午</a></time>

  
    <h1 class="title"><a href="/2015/06/10/position-independent-code/">位置独立代码</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        位置独立代码（Position-independent code)，是在PowerPC环境代码生成技术的名字，它允许动态链接器在不固定的虚拟内存地址中加载一个区域代码。除了位置独立代码生成的一些形式之外，操作系统会把你希望共享的代码放置在虚拟内存固定地址中，这会导致维护操作系统时相当困难。例如，它基本不会支持shared libraries和frameworks，因为他们都需要预先分配一个永远不会变的地址......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/10/position-independent-code/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/10/position-independent-code/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/10/position-independent-code/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-10T07:54:28.000Z"><a href="/2015/06/10/indirect-addressing/">周三, 6月 10 2015, 3:54:28 下午</a></time>

  
    <h1 class="title"><a href="/2015/06/10/indirect-addressing/">间接寻址</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        间接寻址是一种代码生成技术的名字，它允许被定义在文件中的symbols能够被另外一个文件引用，并且不需要引用文件知道任何有关定义这些symbol文件的布局。因此，定义文件能够被独立地修改。间接寻址最小化了动态链接器需要修改的地址，这会提高代码分享和提高效率......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/10/indirect-addressing/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/10/indirect-addressing/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/10/indirect-addressing/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-07T03:03:15.000Z"><a href="/2015/06/07/loading-code_at-runtime/">周日, 6月 7 2015, 11:03:15 上午</a></time>

  
    <h1 class="title"><a href="/2015/06/07/loading-code_at-runtime/">在运行时加载代码</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        你可能需要用到动态分享库，它能够保存可重用代码，在多个程序使用时有函数的使用优势。例如，当你开发Cocoa应用程序时，你的程序最少会链接Foudation和Application Kit框架。通过这个实践，当你的应用程序用户更新电脑系统软件框架时，你的程序能够自动利用那些改进的框架......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/07/loading-code_at-runtime/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/07/loading-code_at-runtime/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/07/loading-code_at-runtime/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-07T00:47:09.000Z"><a href="/2015/06/07/executing-mach-o-file/">周日, 6月 7 2015, 8:47:09 早上</a></time>

  
    <h1 class="title"><a href="/2015/06/07/executing-mach-o-file/">运行Mach-O文件</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        为了展示代码的效果，程序必须启动线程和链接到dynamic shared libraries（动态分享库），为了与其它库和模块一起运行，你的应用程序必须在modules(.o)里面定义符号的引用，这些引用会在运行时被解决。在运行时应用程序中所有modules的symbol名字都会在共享的命名空间中使用。为了允许未来应用程序和使用库的使用，应用程序和库的开发者必须保证他们在功能和数据中选择的名字不会与其它modules冲突......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/07/executing-mach-o-file/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/07/executing-mach-o-file/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/07/executing-mach-o-file/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-05T10:37:57.000Z"><a href="/2015/06/05/executable_mach_o_file/">周五, 6月 5 2015, 6:37:57 晚上</a></time>

  
    <h1 class="title"><a href="/2015/06/05/executable_mach_o_file/">可执行文件Mach-O的结构</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        在Mach-O文件的开头，有一个header结构标记这个文件的类型为Mach-O文件，并且这个结构里面包含了一些其它的信息：如target architecture和其它文件解析的选项等......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/05/executable_mach_o_file/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/05/executable_mach_o_file/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/05/executable_mach_o_file/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-05T10:36:57.000Z"><a href="/2015/06/05/building_mach_o_file/">周五, 6月 5 2015, 6:36:57 晚上</a></time>

  
    <h1 class="title"><a href="/2015/06/05/building_mach_o_file/">构建Mach-O文件</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        为了在运行时展示实际加载和绑定程序的工作，内核会使用动态链接器（一个路径在/usr/lib/dylib被标记为dynamic shared library的工具）。内核会在新的线程中加载程序和动态链接器并且运行他们......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/05/building_mach_o_file/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/05/building_mach_o_file/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/05/building_mach_o_file/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一页<i class="fa fa-long-arrow-right"></i></a>
  
  <div class="clearfix"></div>
</nav>

<script src="/js/jquery.anystretch.min.js" type="text/javascript"></script>
<script src="/js/cover.js" type="text/javascript"></script>

    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div>
  
  &copy; 2015 Weihao Xu
  
</div>
Powered by <a href="http://zespia.tw/hexo/" title="Hexo" target="_blank" rel="external">Hexo</a> and <a href="http://pages.github.com/" title="GitHub Pages" target="_blank" rel="external">GitHub Pages</a>

<div class="clearfix"></div></footer>
  
<script src="/js/jquery.imagesloaded.min.js" type="text/javascript"></script>
<script src="/js/gallery.js" type="text/javascript"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js" type="text/javascript"></script>




    <script type="text/javascript">
        (function(){
                    $("#main-nav").removeClass('normal_mode').addClass('top_mode');
/*
            $(window).scroll(function(){

                var scrollTop = $(window).scrollTop();
                if ( scrollTop > 0 ){
                    $("#main-nav").removeClass('normal_mode').addClass('top_mode');
                } else{
                    $("#main-nav").removeClass('top_mode').addClass('normal_mode');
                }

            });
*/
        })();
    </script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
  (function($){
    $('.fancybox').fancybox({
      'titlePosition': 'inside'
    });
  })(jQuery);
  </script>



    
    <script type="text/javascript">
      var duoshuoQuery = {short_name:"sky-weihao"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = 'http://static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] 
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>



<script type="text/javascript">
  
  $(function(){

    $('.title').hover(
      function() {      
        $(this).stop().animate(
          {'marginLeft': '10px'}, 200
        );   
      }, 
      function() {       
        $(this).stop().animate({'marginLeft': '0px'}, 200);      
      
    });   

  });

</script>


</body>
</html>