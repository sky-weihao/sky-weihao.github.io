<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Sky-Weihao的博客</title>
  <meta name="author" content="Weihao Xu">
  
  <meta name="description" content="欢迎光临寒舍">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Sky-Weihao的博客">

  
    <meta property="og:image" content="undefined">
  

  <link href="/avatar.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Sky-Weihao的博客" type="application/atom+xml">
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
<link rel="stylesheet" href="/css/style.css">
  <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-368771XX-X']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>
</html>
<body>
  <header id="header" class='normal_mode'>
    <nav id="main-nav">
  <ul class="container">
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">文档</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
  </header>
  <div id="content" class="container">
    <div id="cover">
	<div id="profile" alt="http://sky-weihao.github.io/img/background.jpg">
		<a href="/">
			<div class="logo">
				<img src="/avatar.png" alt="Profile Picture">
			</div>
			<div id="title">Sky-Weihao的博客</div>
		</a>

		
			<div id="subtitle">欢迎光临寒舍</div>
		
		 <ul class="my-socials">
  
  <li>
  	<a href="https://github.com/sky-weihao" class="github" target="_blank">
  		<i class="fa fa-github"></i>
  	</a>
  </li>
  
  <li>
  	<a href="http://weibo.com/1867935643/profile" class="weibo" target="_blank">
  		<i class="fa fa-weibo"></i>
  	</a>
  </li>
  
 
 <li>
   	<a href="mailto:110458260@qq.com" class="email" target="_blank" title="Email Me">
  		<i class="fa fa-envelope"></i>
  	</a>
 </li>
 
</ul>
	</div>
</div>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2019-08-07T18:44:00.000Z"><a href="/2019/08/07/unblocking-on-tcp-channel/">周三, 8月 7 2019, 11:44:00 中午</a></time>

  
    <h1 class="title"><a href="/2019/08/07/unblocking-on-tcp-channel/">客户端tcp通道防封禁笔记</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客/">博客</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>最近做了一些关于防封禁和网络安全的一些事情，其中主要是关于tcp通道进行自定义协议收发的防封禁工作，在这段时间对防封禁这一块有更多一些的思考。同时通过跟我们公司中美的后台工程师的讨论，整个流程产生了很多有价值的想法和思考，在IT的各方面我感觉他们非常卓越，在防封禁方案讨论的过程中大部分的想法都是他们提出的建议，让我获益良多。在近期完成了客户端第一版防封禁功能的编码后来到美国出差，工作压力相对轻松，于是趁着这段时间尝试对近期工作内容产生的想法及方案的优缺点大概进行一个整理归纳。自感在这方面修炼还还差得很远，希望大家一起交流沟通。</p>
<h3 id="背景">背景</h3><p>从事开发的很多技术人员都知道，网络稳定性和可用性对于每个应用来说都非常重要，应用中经常会遇到影响网络稳定性的很多不同条件，比如国家政策、运营商情况、目标恶意攻击等，可能也有很多人员在调查网络链接成功率下降或者面对用户反馈服务失败的时候彻夜不眠去定位问题，但是容易陷入到治标不治本的陷阱里面去。如果没有进行任何防封禁的工作，即使在理想情况下，HTTPS服务成功率也只有在98%～99%之间，如果是自定义的tcp协议通道成功率只会比这个数值要低，尤其是在一些有网络限制的国家或多运营商的国家下。</p>
<p>在该方案之前，进行过的防封禁策略就有很多，有关于HTTPS防封禁和tcp防封禁的，比如：<br>备用域名替换、http前置后置ip(http dns)、tcp/udp切换、端口切换、云服务转发等。这里只对HTTPS伪装方案进行了说明。</p>
<p>为了提升网络的稳定性与可用性，可以通过以下一些建议得到一些启发：</p>
<h3 id="基于SSL/TLS的tcp通道伪装">基于SSL/TLS的tcp通道伪装</h3><p>首先，我们可以通过把自定义协议格式伪装起来，让他们看起来是正常的https协议，而不是私有协议格式。这是防封禁中最基础的一件事情，因为HTTPS是所有国家互联网中广泛应用。</p>
<p>关于SSL/TLS协议的更多定义，你们可以通过以下链接查阅：<br><a href="https://www.rfc-editor.org/rfc/rfc5246.txt" target="_blank" rel="noopener">RFC 5246</a><br><a href="http://blog.fourthbit.com/2014/12/23/traffic-analysis-of-an-ssl-slash-tls-session" target="_blank" rel="noopener">Traffic Analysis of an SSL/TLS Session</a></p>
<h4 id="基本特性">基本特性</h4><p>伪装的主要目的是能够防止运营商通过一些应用交互协议行为特征对app进行封禁，假设你当前网络交互的消息是这样的（先不考虑安全性）：<br><code>message = data length(4 bytes) + data</code><br>在这种情况下，它很容易被识别到有以下特征：</p>
<ol>
<li>自定义协议</li>
<li>长度前面的bits大多都为0</li>
</ol>
<p>在我们使用TLS ApplicationData的头对我们协议进行简单伪装之后，协议会变为这样：<br><code>message = TLS record(5 bytes) + counter(8bytes) + data length(4 bytes) + data</code><br>这时看起来有什么特别?  此时已经有一个TLS ApplicationData子协议的头及他的counter。但当你通过Wireshark观察这个协议，你仍然能通过协议的多个为0 的bits及明文的数据找到这条协议的特征。</p>
<p>因此下一步需要使该协议的数据部分进行随机化<br>TLS协议的初始作用是在TLS handshake交互中协商出能用于后续进行对称性加密的key，并在业务协议交互过程中使用该key对数据进行加密，因此，如果有通过正式TLS协商过程的协议会是这样<br><code>message = TLS record(5 bytes) + counter(8bytes) +  encrypted(data length(4 bytes) + data)</code></p>
<p>这里有一个问题，有人会问到tls record 中后两个bytes是记录当前tls proto的length，那data length是否是可以不用？答案是：否，原因是由于tls一个message的长度只支持最长65535 bytes，在某些情况下自定义消息长度会大于该长度，若需要进行扩展则需要data length。另外一个case是在防封禁中，有时候需要把自定义协议打散为多条tls 协议发送（即使协议长度没到达65535），因此需要在客户端对数据进行拼接，所以data length字段在message的首个tls协议中必须是含有的。</p>
<p>到此为止，tcp消息进行tls伪装的基调已经能定下来了，其中两个要素</p>
<ol>
<li>为TLS record 子协议类型的协议类型</li>
<li>业务协议的内容通过加密，其中的内容无法通过任何行为特征进行分析</li>
</ol>
<h4 id="使用TLS_1-1中TLS_Resumption进行握手的特性">使用TLS 1.1中TLS Resumption进行握手的特性</h4><p>如果实现了上述的基础特性，可能已经能解决协议特征行为识别的问题，运营商或者封禁技术人员已经无法识别你的协议是否是私有协议，他们只能认为你发送的消息与所有的https消息一样。<br>但在tcp正式发送tls伪装的消息前与tcp 三次握手链接成功之间的时间段，因使用tls则引入了一些能进行识别的因素。正常使用HTTPS需要先通过SSL/TLS握手验证，简单概括TLS正常握手过程为协商双方使用配置、验证身份、基于rsa算法协商并生成对称性加密key。 如果在不进行TLS握手的情况下直接使用TLS Record的ApplicationData子协议，运营商能可能会发现你们应用ip的流量上有异常，然后通过该路径进行识别进行封禁。</p>
<p>如果使用常规的TLS handshake流程，需要两个rtt进行交互。</p>
<ol>
<li>Client Hello</li>
<li>Server Hello, Certificate, Server Hello Done</li>
<li>Client Key Exchanged, Client Changed Cipher Spec, Finished</li>
<li>Server Changed Cipher Spec, Finished</li>
</ol>
<p>因此可以使用比较新的TLS 1.1的特性TLS Resumption handshake来模拟这一步交互，降低TLS 伪装交互所需的耗时，TLS Resumption的流程如下：  </p>
<ol>
<li>Client Hello</li>
<li>Server Hello, Change Cipher Spec, Finished</li>
<li>Client Changed Cipher Spec, Finished<br>在Client Finished之后，我们就能发送业务协议了。</li>
</ol>
<p>到此，已经又解决了一个问题，已经较完整把tcp通道伪装成了HTTPS协议的交互模式，而且能在可以暂时不考虑安全的情况下，通过TLS一些较新的特性降低TLS伪装的耗时。  </p>
<h4 id="关注更多TLS_handshake交互过程中的细节">关注更多TLS handshake交互过程中的细节</h4><p>通过回顾SSL/TLS的定义，我们能发现使用TLS resumption伪装的过程中仍有非常多的细节没有处理，主要信息在Client Hello与Server Hello中，若tls handshake的过程需要自己去实现，这时整个协议细节都可以进行调整，其中配置大致包含:</p>
<ol>
<li>TLS record header</li>
<li>32 bytes random bytes</li>
<li>Session ID</li>
<li>Cipher Suite</li>
<li>Compression Suite </li>
<li>Server name indicator</li>
<li>Signature algo<br>其中recorder header、session ID、cipher suite、compression suite、signature algo正常情况都是用于客户端与服务器协议的作用，这方面在防封禁上意义没那么大，其中最重要的是server name indicator，若你一直使用应用本身注册的domain，极容易出现针对性封禁（即某个国家或者运营商故意对该应用进行检测封禁，无论是https或者是tcp，都通过强硬的手段恶意封禁）。在这种情况下，我们的https伪装可以伪装得更好去解决这个问题。我们通过动态配置填写SNI字段，比如填写baidu.com，然后其他的配置也根据模拟目标域名的https配置进行下发替换。</li>
</ol>
<p>OK，这时又解决一个难题，显然这个时候运营商已经较难识别到你app发送出来的数据是否是真的还是假的，他会认为这时你发出来的数据是百度、谷歌等app发送出来，极难通过网络数据行为分析针对你的app进行封禁（当然仍有其他方法进行封禁，但是封禁成本都已经非常高了）。</p>
<p>总结一下上面的方法就是为https伪装，让你自定义的协议看上去是一个HTTPS链接交互，但里面传输的内容却是自定义协议：</p>
<ol>
<li>伪装SSL/TLS握手流程</li>
<li>伪装数据包为TLS ApplicationData数据包<br>上面两步的每一步都是可以进行很多变化，这些都基于你的app实际需要使用的情况，但是思想离不开这两步。例如，如果也希望在tls handshake过程中验证服务器可靠性、进行密钥协商，均可以在伪装的过程中也利用TLS原有的特性。数据包格式也可以进行各种优化，如统一协议头、可变长度、协议压缩等。</li>
</ol>
<h4 id="Security">Security</h4><p>在安全性方面，我们这边的方案大概使用了0-RTT Pre Shared Key的方式进行密钥协商。涉及到安全相关，对于使用方案相关的策略不方便太多展开描述，大致进行几个原则说明。  </p>
<ol>
<li>使用0-RTT 的策略主要是考虑在TLS伪装之后，需要尽快进行业务协议交互，能直接使用AES方式进行对称性加密及业务数据传输，降低TLS伪装带来的额外损耗。</li>
<li>能覆盖使用TLS resumption策略从而没有对服务器进行身份校验的问题</li>
<li>在上述基础上需增加一些额外的安全策略</li>
</ol>
<p>其他详细的扩展阅读可以看微信的文章，描述ECDH与PSK协商策略非常详细。<br><a href="https://github.com/WeMobileDev/article/blob/master/基于TLS1.3的微信安全通信协议mmtls介绍.md" target="_blank" rel="noopener">基于TLS1.3的微信安全通信协议mmtls介绍</a></p>

      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2019/08/07/unblocking-on-tcp-channel/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2019/08/07/unblocking-on-tcp-channel/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2019/08/07/unblocking-on-tcp-channel/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2019-05-20T18:04:51.000Z"><a href="/2019/05/20/reuse-block/">周一, 5月 20 2019, 11:04:51 上午</a></time>

  
    <h1 class="title"><a href="/2019/05/20/reuse-block/">项目中使用sqlite数据库使用异常情况总结</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客/">博客</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>闲聊：好久没有更新博客啦，近期由于工作上的一些原因，相对来说比之前要有空一点，在逐步整理一下之前在做的一些事情，可是之前做的事情也没有进行太详细严谨的记录，包括怎样重新使用hexo更新文章到blog，还有markdown的语法都已经确实忘记得差不多了，只能逐渐恢复下先更新一点，不过文章先更新上来，文章的质量还要等我熟悉blog这块怎样更新要持续进行优化，感谢大家观看。<br>项目中使用了fmdb作为sqlite数据库上层封装控件，简单总结一下此前进行数据库数据异常丢失，数据库访问失败的原因情况：<br>如果在进行sql操作失败时有打印相关日志，会看到这条输出：“操作数据库失败！ error:Error Domain=FMDatabase Code=11 “database disk image is malformed” UserInfo={NSLocalizedDescription=database disk image is malformed}”<br>当有这句输出时，sqlite数据库中的结构已经是损坏了，当然有可能是master表有损坏，也有可能只是其中一部分数据表有损坏。<br>以下来分析一下与数据库配置属性有关的一些参数，如果在数据库使用时没有设置好这些参数，会极大提升数据库损坏率。</p>
<h4 id="1、设置了PRAGMA_journal_mode_=_OFF">1、设置了PRAGMA journal_mode = OFF</h4><p>OFF日志模式让SQLite放弃在开始时创建回滚日志，它会禁用SQLite的原子提交和回滚功能，让ROLLBACK命令不可用。如果使用OFF日志模式的事务在中间某时刻发生崩溃或断电，则数据库文件不能恢复，可能会被损坏。<br><a id="more"></a></p>
<h4 id="日志模式">日志模式</h4><p>SQLite中日志模式主要有DELETE和WAL两种，其他几种比如TRUNCATE，PERSIST，MEMORY基本原理都与DELETE模式相同，不作详细展开。DELETE模式采用影子分页技术(Shadow paging)，DELETE模式下，日志中记录的变更前数据页内容；WAL模式下，日志中记录的是变更后的数据页内容。事务提交时，DELETE模式将日志刷盘，将DB文件刷盘，成功后，再将日志文件清理；WAL模式则是将日志文件刷盘，即可完成提交过程。那么WAL模式下，数据文件何时更新呢？这里引入了检查点概念，检查点的作用就是定期将日志中的新页覆盖DB文件中的老页，并通过参数wal_autocheckpoint来控制检查点时机，达到权衡读写的目的。<br>DELETE模式下，写事务直接更新db-page，并将old-page写入日志，读事务则直接读db-page，因为db-page中保存了提交的所有事务的更新。事务提交后，直接将日志文件删除；若事务需要回滚，则将日志中old-page中的内容覆盖db-page，恢复原始内容。WAL模式下，写事务将更新写到日志文件中，不更新db-page，事务提交时，也不影响db-page，只是将日志持久化而已。若事务回滚，则不将日志写入文件即可。由于最新的数据在日志文件中，那么如何读取到最新的数据呢？WAL模式通过end-mark(事务提交位点)达到这一目的。具体而已，事务开始时，会首先扫描日志文件，获取最近一个end-mark，在读取数据时，首先会判断page是否在wal日志文件中存在，因为同一个page，一定是wal文件中的比db文件中的要新。如果存在，则使用，否则，再从db文件中获取指定的page。从流程上来看，这个过程比较慢，因为极端情况下，每次读都需要扫描wal文件和db文件。为了提高性能，WAL模式中有一个wal-index文件，这个文件记录了页号和该页在WAL文件中的偏移，并且wal-index文件采用共享缓存实现，从文件名也可以看到，后缀是.shm，因此判断page是否在wal文件存在的操作实质是一次内存读。wal-index采用hash表存储，因此查询效率也非常高。与传统的DBMS不同，SQLite中记录的日志，实质是dirty-page，重做实质是对利用WAL中的日志页覆盖db-page，这种实现方式比较简单，同时也比较浪费空间，因为一个page是1k，即使只更新1byte，也会导致日志记录1k。<br>我们可以在数据库建立时就改变日志模式，但改变为wal模式后，该模式是不可逆的，而除了wal模式外其他模式可以进行变更。<br>WAL日志模式优点：<br>1) 读写可以并发，不会阻塞<br>2）只有一个WAL文件，性能优势明显。</p>
<h4 id="2、PRAGMA_synchronous_=_OFF">2、PRAGMA synchronous = OFF</h4><p>The sync operations that SQLite performs to help ensure integrity can be disabled at run-time using the synchronous pragma. By setting PRAGMA synchronous=OFF, all sync operations are omitted. This makes SQLite seem to run faster, but it also allows the operating system to freely reorder writes, which could result in database corruption if a power failure or hard reset occurs prior to all content reaching persistent storage.<br>For maximum reliability and for robustness against database corruption, SQLite should always be run with its default synchronous setting of FULL.  </p>
<h4 id="常见使用sqlite进行的默认属性配置">常见使用sqlite进行的默认属性配置</h4><ol>
<li>PRAGMA locking_mode=NORMAL  //与事务读写时锁持有时常有关</li>
<li>PRAGMA synchronous=FULL  //是否每次写事务都同步到磁盘中</li>
<li>PRAGMA journal_mode=DELETE  //数据库模式</li>
<li>PRAGMA fullfsync=NO  //是否按写入内存的顺序写入磁盘空间</li>
</ol>
<h4 id="推荐使用以下sqlite的配置：">推荐使用以下sqlite的配置：</h4><p>PRAGMA journal_mode = WAL<br>PRAGMA synchronous = NORMAL<br>PRAGMA locking_mode=EXCLUSIVE<br>同时附上了微信WCDB（也是建立在sqlite上）对数据库属性的默认配置进行参考，其也是开启了wal模式，并且没有对数据库读写synchronous设置为FULL。<br>/**<br>brief Default config name.<br>The default config for WCDB is :</p>
<ol>
<li>PRAGMA locking_mode=NORMAL</li>
<li>PRAGMA synchronous=NORMAL</li>
<li>PRAGMA journal_mode=WAL</li>
<li>PRAGMA fullfsync=ON<br>Setting config for this name will overwrite the default config.<br>return default config name<br>*/</li>
</ol>
<h4 id="但无论在任何情况及设计任何配置的情况下，数据库文件总会在某在异常情况下崩溃并且造成永久性损坏，这时候就需要我们引入一些数据库修复策略。">但无论在任何情况及设计任何配置的情况下，数据库文件总会在某在异常情况下崩溃并且造成永久性损坏，这时候就需要我们引入一些数据库修复策略。</h4><p>数据库修复策略（目前已知在app里内无法使用.dump命令到sql语句）</p>
<ol>
<li>使用sqlite3_backup_init、sqlite3_backup_step、sqlite3_backup_finish方法进行数据库文件备份（目前已经实现）<br>当发现数据库损坏时，使用相对应方法使用备份文件进行修复，使用双重备份提高成功率<br>优点：</li>
</ol>
<ul>
<li>sqlite3库自带方法，使用比较方便</li>
<li>sqlite网上可查找相关的备份方法说明文档</li>
<li>恢复快<br>缺点：</li>
<li>未知修复成功率能达到多少  </li>
<li>压缩后没有dump方法的数据量少 不适合db损坏率较低的场景</li>
<li>备份耗时比较长</li>
<li>无法解决用户数据库已损坏情况的恢复<br>难度：<br>实现难度低，fmdb新版本中有支持。<br></li>
</ul>
<ol>
<li>自己实现dump方法<br>优点：</li>
</ol>
<ul>
<li>容量小、备份耗时中等</li>
<li>能针对数据库非master表部分损坏的情况进行修复<br>缺点：</li>
<li>实现dump的相关执行语句需要自己实现</li>
<li>恢复慢<br>难度：<br>中等</li>
</ul>
<ol>
<li>使用微信wcdb repairKit方法进行数据库备份和恢复。大概逻辑为进行Master表备份，损坏时读取Master表记录的各业务表的根节点，遍历BTree读出各表各行数据，重建数据库。（微信的修复方案）<br><a href="https://github.com/WeMobileDev/article/blob/master/%E5%BE%AE%E4%BF%A1%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%84%E4%BB%B6WCDB%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%20%E2%80%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%AE%E5%A4%8D%E4%B8%89%E6%9D%BF%E6%96%A7.md" target="_blank" rel="noopener">详情可看微信数据库技术文章</a><br>优点：</li>
</ol>
<ul>
<li>微信验证修复成功率达90%以上</li>
<li>能进行压缩，压缩比较高</li>
<li>支持加解密</li>
<li>支持ORM，比fmdb读写速度快<br>缺点：</li>
<li>需要读懂分析微信wcdb中的代码或者把项目接入从fmdb的使用迁移wcdb到项目中，并去除项目中fmdb的引用。<br>难度：<br>项目迁移成本较大</li>
</ul>
<p>参考文章：<br><a href="https://blog.csdn.net/wql2rainbow/article/details/73650056?utm_source=blogxgwz20" target="_blank" rel="noopener">https://blog.csdn.net/wql2rainbow/article/details/73650056?utm_source=blogxgwz20</a><br><a href="https://www.sqlite.org/wal.html" target="_blank" rel="noopener">https://www.sqlite.org/wal.html</a><br><a href="https://blog.csdn.net/chinaclock/article/details/48622243" target="_blank" rel="noopener">https://blog.csdn.net/chinaclock/article/details/48622243</a><br><a href="http://garyliutw.blogspot.com/2013/07/sqlite_24.html" target="_blank" rel="noopener">http://garyliutw.blogspot.com/2013/07/sqlite_24.html</a><br><a href="http://www.runoob.com/sqlite/sqlite-pragma.html" target="_blank" rel="noopener">http://www.runoob.com/sqlite/sqlite-pragma.html</a></p>

      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2019/05/20/reuse-block/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2019/05/20/reuse-block/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2019/05/20/reuse-block/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-10-06T17:49:41.000Z"><a href="/2015/10/06/Video-streaming-and-caching-in-iOS/">周二, 10月 6 2015, 10:49:41 上午</a></time>

  
    <h1 class="title"><a href="/2015/10/06/Video-streaming-and-caching-in-iOS/">iOS音视频实现边下载边播放</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，原创博客/">博客，原创博客</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>近段时间制作视频播放社区的功能，期间查找了不少资料，做过很多尝试，现在来整理一下其中遇到的一些坑.由于考虑到AVPlayer对视频有更高自由度的控制，而且能够使用它自定义视频播放界面，iOS中所使用的视频播放控件为AVPlayer，而抛弃了高层次的MediaPlayer框架，现在想想挺庆幸当初使用了AVPlayer。</p>
<h3 id="AVPlayer的基本知识">AVPlayer的基本知识</h3><p>AVPlayer本身并不能显示视频，而且它也不像MPMoviePlayerController有一个view属性。如果AVPlayer要显示必须创建一个播放器层AVPlayerLayer用于展示，播放器层继承于CALayer，有了AVPlayerLayer之添加到控制器视图的layer中即可。要使用AVPlayer首先了解一下几个常用的类：</p>
<p>AVAsset：主要用于获取多媒体信息，是一个抽象类，不能直接使用。</p>
<p>AVURLAsset：AVAsset的子类，可以根据一个URL路径创建一个包含媒体信息的AVURLAsset对象。</p>
<p>AVPlayerItem：一个媒体资源管理对象，管理者视频的一些基本信息和状态，一个AVPlayerItem对应着一个视频资源。</p>
<h3 id="iOS视频实现边下载边播放的几种实现">iOS视频实现边下载边播放的几种实现</h3><h4 id="1-本地实现http_server">1.本地实现http server</h4><p>在iOS本地开启Local Server服务，然后使用播放控件请求本地Local Server服务，本地的服务再不断请求视频地址获取视频流，本地服务请求的过程中把视频缓存到本地，这种方法在网上有很多<a href="http://code4app.com/ios/%E8%A7%86%E9%A2%91%E8%BE%B9%E4%B8%8B%E8%BD%BD%E8%BE%B9%E6%92%AD%E6%94%BE/5292c381cb7e8445678b5ac2#" target="_blank" rel="noopener">例子</a>，有兴趣了解的人可自己下载例子查看。</p>
<h4 id="2-使用AVPlayer的方法开启下载服务">2.使用AVPlayer的方法开启下载服务</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">AVURLAsset</span> *urlAsset = [[<span class="built_in">AVURLAsset</span> alloc]initWithURL:url options:<span class="literal">nil</span>];</span><br><span class="line"><span class="number">2.</span><span class="built_in">AVPlayerItem</span> *item = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:urlAsset];</span><br><span class="line"><span class="number">3.</span>[<span class="keyword">self</span>.avPlayer replaceCurrentItemWithPlayerItem:item];</span><br><span class="line"><span class="number">4.</span>[<span class="keyword">self</span> addObserverToPlayerItem:item];</span><br></pre></td></tr></table></figure>
<p>但由于AVPlayer是没有提供方法给我们直接获取它下载下来的数据，所以我们只能在视频下载完之后自己去寻找缓存视频数据的办法，AVFoundation框架中有一种从多媒体信息类AVAsset中提取视频数据的类AVMutableComposition和AVAssetExportSession。<br>其中AVMutableComposition的作用是能够从现有的asset实例中创建出一个新的AVComposition(它也是AVAsset的字类)，使用者能够从别的asset中提取他们的音频轨道或视频轨道，并且把它们添加到新建的Composition中。<br>AVAssetExportSession的作用是把现有的自己创建的asset输出到本地文件中。<br>为什么需要把原先的AVAsset(AVURLAsset)实现的数据提取出来后拼接成另一个AVAsset(AVComposition)的数据后输出呢，由于通过网络url下载下来的视频没有保存视频的原始数据（或者苹果没有暴露接口给我们获取），下载后播放的avasset不能使用AVAssetExportSession输出到本地文件，要曲线地把下载下来的视频通过重构成另外一个AVAsset实例才能输出。代码例子如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">NSString</span> <span class="meta">*documentDirectory</span> <span class="string">=</span> <span class="string">NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,</span> <span class="string">NSUserDomainMask,</span> <span class="literal">YES</span><span class="string">)[0];</span></span><br><span class="line"><span class="string">NSString</span> <span class="meta">*myPathDocument</span> <span class="string">=</span> <span class="string">[documentDirectory</span> <span class="attr">stringByAppendingPathComponent:[NSString</span> <span class="attr">stringWithFormat:@"%@.mp4",[_source.videoUrl</span> <span class="string">MD5]]];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">NSURL</span> <span class="meta">*fileUrl</span> <span class="string">=</span> <span class="string">[NSURL</span> <span class="attr">fileURLWithPath:myPathDocument];</span></span><br><span class="line"></span><br><span class="line"><span class="string">if</span> <span class="string">(asset</span> <span class="string">!=</span> <span class="string">nil)</span> <span class="string">&#123;</span></span><br><span class="line"><span class="string">AVMutableComposition</span> <span class="meta">*mixComposition</span> <span class="string">=</span> <span class="string">[[AVMutableComposition</span> <span class="string">alloc]init];</span></span><br><span class="line"><span class="string">AVMutableCompositionTrack</span> <span class="meta">*firstTrack</span> <span class="string">=</span> <span class="string">[mixComposition</span> <span class="attr">addMutableTrackWithMediaType:AVMediaTypeVideo</span> <span class="attr">preferredTrackID:kCMPersistentTrackID_Invalid];</span></span><br><span class="line"><span class="string">[firstTrack</span> <span class="attr">insertTimeRange:CMTimeRangeMake(kCMTimeZero,</span> <span class="string">asset.duration)</span> <span class="attr">ofTrack:[[asset</span> <span class="attr">tracksWithMediaType:AVMediaTypeVideo]objectAtIndex:0]</span> <span class="attr">atTime:kCMTimeZero</span> <span class="attr">error:nil];</span></span><br><span class="line"></span><br><span class="line"><span class="string">AVMutableCompositionTrack</span> <span class="meta">*audioTrack</span> <span class="string">=</span> <span class="string">[mixComposition</span> <span class="attr">addMutableTrackWithMediaType:AVMediaTypeAudio</span> <span class="attr">preferredTrackID:kCMPersistentTrackID_Invalid];</span></span><br><span class="line"><span class="string">[audioTrack</span> <span class="attr">insertTimeRange:CMTimeRangeMake(kCMTimeZero,</span> <span class="string">asset.duration)</span> <span class="attr">ofTrack:[[asset</span> <span class="attr">tracksWithMediaType:AVMediaTypeAudio]objectAtIndex:0]</span> <span class="attr">atTime:kCMTimeZero</span> <span class="attr">error:nil];</span></span><br><span class="line"></span><br><span class="line"><span class="string">AVAssetExportSession</span> <span class="meta">*exporter</span> <span class="string">=</span> <span class="string">[[AVAssetExportSession</span> <span class="string">alloc]initWithAsset:mixComposition</span> <span class="attr">presetName:AVAssetExportPresetHighestQuality];</span></span><br><span class="line"><span class="string">exporter.outputURL</span> <span class="string">=</span> <span class="string">fileUrl;</span></span><br><span class="line"><span class="string">if</span> <span class="string">(exporter.supportedFileTypes)</span> <span class="string">&#123;</span></span><br><span class="line"><span class="string">exporter.outputFileType</span> <span class="string">=</span> <span class="string">[exporter.supportedFileTypes</span> <span class="attr">objectAtIndex:0]</span> <span class="string">;</span></span><br><span class="line"><span class="string">exporter.shouldOptimizeForNetworkUse</span> <span class="string">=</span> <span class="literal">YES</span><span class="string">;</span></span><br><span class="line"><span class="string">[exporter</span> <span class="attr">exportAsynchronouslyWithCompletionHandler:^&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#125;];</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-使用AVAssetResourceLoader回调下载，也是最终决定使用的技术">3.使用AVAssetResourceLoader回调下载，也是最终决定使用的技术</h3><p>AVAssetResourceLoader通过你提供的委托对象去调节AVURLAsset所需要的加载资源。<strong>而很重要的一点是，AVAssetResourceLoader仅在AVURLAsset不知道如何去加载这个URL资源时才会被调用，就是说你提供的委托对象在AVURLAsset不知道如何加载资源时才会得到调用</strong>。所以我们又要通过一些方法来曲线解决这个问题，把我们目标视频URL地址的scheme替换为系统不能识别的scheme，然后在我们调用网络请求去处理这个URL时把scheme切换为原来的scheme。</p>
<p>实现边下边播功能AVResourceLoader的委托对象必须要实现AVAssetResourceLoaderDelegate下五个协议的其中两个：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">1</span><span class="comment">//在系统不知道如何处理URLAsset资源时回调</span></span><br><span class="line"><span class="selector-tag">-</span> (BOOL)<span class="selector-tag">resourceLoader</span><span class="selector-pseudo">:(AVAssetResourceLoader</span> *)<span class="selector-tag">resourceLoader</span> <span class="selector-tag">shouldWaitForLoadingOfRequestedResource</span><span class="selector-pseudo">:(AVAssetResourceLoadingRequest</span> *)<span class="selector-tag">loadingRequest</span> <span class="selector-tag">NS_AVAILABLE</span>(<span class="number">10</span>_9, <span class="number">6</span>_0);</span><br><span class="line"><span class="selector-tag">2</span><span class="comment">//在取消加载资源后回调</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">resourceLoader</span><span class="selector-pseudo">:(AVAssetResourceLoader</span> *)<span class="selector-tag">resourceLoader</span> <span class="selector-tag">didCancelLoadingRequest</span><span class="selector-pseudo">:(AVAssetResourceLoadingRequest</span> *)<span class="selector-tag">loadingRequest</span> <span class="selector-tag">NS_AVAILABLE</span>(<span class="number">10</span>_9, <span class="number">7</span>_0);</span><br></pre></td></tr></table></figure>
<p>以下来说说具体要怎么做处理</p>
<h4 id="第一步，创建一个AVURLAsset，并且用它来初始化一个AVPlayerItem">第一步，创建一个AVURLAsset，并且用它来初始化一个AVPlayerItem</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define kCustomVideoScheme @<span class="meta-string">"yourScheme"</span></span></span><br><span class="line"><span class="built_in">NSURL</span> *currentURL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://***.***.***"</span>];</span><br><span class="line"><span class="built_in">NSURLComponents</span> *components = [[<span class="built_in">NSURLComponents</span> alloc]initWithURL:currentURL resolvingAgainstBaseURL:<span class="literal">NO</span>];</span><br><span class="line"><span class="number">1</span><span class="comment">////注意，不加这一句不能执行到回调操作</span></span><br><span class="line">components.scheme = kCustomVideoScheme;</span><br><span class="line"><span class="built_in">AVURLAsset</span> *urlAsset = [<span class="built_in">AVURLAsset</span> URLAssetWithURL:components.URL  </span><br><span class="line">options:<span class="literal">nil</span>];</span><br><span class="line"><span class="number">2</span><span class="comment">//_resourceManager在接下来讲述</span></span><br><span class="line">[urlAsset.resourceLoader setDelegate:_resourceManager queue:dispatch_get_main_queue()];</span><br><span class="line"><span class="built_in">AVPlayerItem</span> *item = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:urlAsset];</span><br><span class="line">_playerItem = item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IOS9_OR_LATER) &#123;</span><br><span class="line">item.canUseNetworkResourcesForLiveStreamingWhilePaused = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span>.avPlayer replaceCurrentItemWithPlayerItem:item];</span><br><span class="line"><span class="keyword">self</span>.playerLayer.player = <span class="keyword">self</span>.avPlayer;</span><br><span class="line">[<span class="keyword">self</span> addObserverToPlayerItem:item];**</span><br></pre></td></tr></table></figure>
<h4 id="第二步，创建AVResourceManager实现AVResourceLoader协议">第二步，创建AVResourceManager实现AVResourceLoader协议</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">interface</span> AVAResourceLoaderManager : <span class="type">NSObject</span> &lt; AVAssetResourceLoaderDelegate &gt;</span><br></pre></td></tr></table></figure>
<h4 id="第三步，实现两个必须的回调协议，实现中有几件需要做的事情">第三步，实现两个必须的回调协议，实现中有几件需要做的事情</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">1</span><span class="comment">//获取系统中不能处理的URL</span></span><br><span class="line"><span class="built_in">NSURL</span> *resourceURL = [loadingRequest.request URL];</span><br><span class="line"><span class="number">2</span><span class="comment">//判断这个URL是否遵守URL规范和其是否是我们所设定的URL</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> checkIsLegalURL:resourceURL] &amp;&amp; [resourceURL.scheme isEqualToString:kCustomVideoScheme])&#123;</span><br><span class="line"><span class="number">3</span><span class="comment">//判断当前的URL网络请求是否已经被加载过了，如果缓存中里面有URL对应的网络加载器(自己封装，也可以直接使用NSURLRequest)，则取出来添加请求，每一个URL对应一个网络加载器，loader的实现接下来会说明</span></span><br><span class="line"><span class="built_in">AVResourceLoaderForASI</span> *loader = [<span class="keyword">self</span> asiresourceLoaderForRequest:loadingRequest];</span><br><span class="line"><span class="keyword">if</span> (loader == <span class="literal">nil</span>)&#123;</span><br><span class="line">loader = [[<span class="built_in">AVResourceLoaderForASI</span> alloc] initWithResourceURL:resourceURL];</span><br><span class="line">loader.delegate = <span class="keyword">self</span>;</span><br><span class="line"><span class="number">4</span><span class="comment">//缓存网络加载器</span></span><br><span class="line">[<span class="keyword">self</span>.resourceLoaders setObject:loader forKey:[<span class="keyword">self</span> keyForResourceLoaderWithURL:resourceURL]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span><span class="comment">//加载器添加请求</span></span><br><span class="line">[loader addRequest:loadingRequest];</span><br><span class="line"><span class="number">6</span><span class="comment">//返回YES则表明使用我们的代码对AVAsset中请求网络资源做处理</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader didCancelLoadingRequest:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果用户在下载的过程中调用者取消了获取视频,则从缓存中取消这个请求</span></span><br><span class="line"><span class="built_in">NSURL</span> *resourceURL = [loadingRequest.request URL];</span><br><span class="line"><span class="built_in">NSString</span> *actualURLString = [<span class="keyword">self</span> actualURLStringWithURL:resourceURL];</span><br><span class="line"><span class="built_in">AVResourceLoaderForASI</span> *loader = [_resourceLoaders objectForKey:actualURLString];</span><br><span class="line">[loader removeRequest:loadingRequest];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第四步，判断缓存中是否已下载完视频">第四步，判断缓存中是否已下载完视频</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addRequest:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1判断自身是否已经取消加载</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">self</span>.isCancelled==<span class="literal">NO</span>)&#123;</span><br><span class="line"><span class="comment">//2判断本地中是否已经有文件的缓存，如果有，则直接从缓存中读取数据，文件保存和读取这里不做详述，使用者可根据自身情况创建文件系统</span></span><br><span class="line"><span class="built_in">AVAResourceFile</span> *resourceFile = [<span class="keyword">self</span>.resourceFileManager resourceFileWithURL:<span class="keyword">self</span>.resourceURL];</span><br><span class="line"><span class="keyword">if</span> (resourceFile) &#123;</span><br><span class="line"><span class="comment">//3若本地文件存在，则从文件中获取以下属性  </span></span><br><span class="line">loadingRequest.contentInformationRequest.byteRangeAccessSupported = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">//3.1contentType</span></span><br><span class="line">loadingRequest.contentInformationRequest.contentType = resourceFile.contentType;</span><br><span class="line"><span class="comment">//3.2数据长度          		  </span></span><br><span class="line">loadingRequest.contentInformationRequest.contentLength = resourceFile.contentLength;</span><br><span class="line"><span class="comment">//3.3请求的偏移量</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> requestedOffset = loadingRequest.dataRequest.requestedOffset;</span><br><span class="line"><span class="comment">//3.4请求总长度</span></span><br><span class="line"><span class="built_in">NSInteger</span> requestedLength = loadingRequest.dataRequest.requestedLength;</span><br><span class="line"><span class="comment">//3.5取出本地文件中从偏移量到请求长度的数据</span></span><br><span class="line"><span class="built_in">NSData</span> *subData = [resourceFile.data subdataWithRange:<span class="built_in">NSMakeRange</span>(@(requestedOffset).unsignedIntegerValue, requestedLength)];</span><br><span class="line"><span class="comment">//3.6返回数据给请求</span></span><br><span class="line">[loadingRequest.dataRequest respondWithData:subData];</span><br><span class="line">[loadingRequest finishLoading];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//4如果没有本地文件，则开启网络请求，从网络中获取 ,见第五步 </span></span><br><span class="line">[<span class="keyword">self</span> startWithRequest:loadingRequest];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//5如果已经取消请求，并且请求没有完成，则封装错误给请求，可自己实现</span></span><br><span class="line"><span class="keyword">if</span>(loadingRequest.isFinished==<span class="literal">NO</span>)&#123;</span><br><span class="line">[loadingRequest finishLoadingWithError:[<span class="keyword">self</span> loaderCancelledError]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第五步，添加loadingRequest到网络文件加载器，这部分的操作比较长">第五步，添加loadingRequest到网络文件加载器，这部分的操作比较长</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startWithRequest:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">1</span><span class="comment">//判断当前请求是否已经开启，由于苹果系统原因，会有两次回调到AVResourceLoaderDelegate，我们对其进行判断，只开启一次请求</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.dataTask == <span class="literal">nil</span>)&#123;</span><br><span class="line"><span class="number">2</span><span class="comment">//根据loadingRequest中的URL创建NSURLRequest，注意在此把URL中的scheme修改为原先的scheme</span></span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="keyword">self</span> requestWithLoadingRequest:loadingRequest];</span><br><span class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="number">3</span><span class="comment">//获取url的绝对路径，并使用ASIHttpRequest进行网络请求，下面的请求方法经过封装，就不详说如何对ASI进行封装了，但是每一步需要做的事情能以block的形式更好说明</span></span><br><span class="line"><span class="built_in">NSString</span> *urlString = request.URL.absoluteString;</span><br><span class="line"><span class="keyword">self</span>.dataTask = [<span class="keyword">self</span> GET:urlString requestBlock:^(Request *req) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s %@ ###"</span>, __func__, req);</span><br><span class="line"><span class="number">4</span><span class="comment">//在接受到请求头部信息时，说明链接成功，数据开始传输</span></span><br><span class="line"><span class="keyword">if</span> (req.recvingHeader<span class="comment">//意思是请求接受到头部信息状态)&#123;</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s recvingHeader ###"</span>, __func__);</span><br><span class="line">__<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"><span class="keyword">if</span> ([urlString isEqualToString:req.originalURL.absoluteString]) &#123;</span><br><span class="line"><span class="number">4.1</span><span class="comment">//，创建临时数据保存网络下载下来的视频信息</span></span><br><span class="line">strongSelf.tempData = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4.2</span><span class="comment">//把头部信息内容写入到AVAssetResourceLoadingRequest，即loadingRequest中</span></span><br><span class="line">[strongSelf processPendingRequests];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (req.recving<span class="comment">//请求接受中状态)&#123;</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s recving ###"</span>, __func__);</span><br><span class="line">__<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"><span class="number">5</span><span class="comment">//此处需多次调用把请求的信息写入到loadingRequest的步骤，实现下载的过程中数据能输出到loadingRequest播放</span></span><br><span class="line"><span class="keyword">if</span> (urlString == req.originalURL.absoluteString) &#123;</span><br><span class="line"><span class="number">5.1</span><span class="comment">//这个处理是判断此时返回的头部信息是重定向还是实际视频的头部信息，如果是重定向信息，则不作处理</span></span><br><span class="line"><span class="keyword">if</span> (!_contentInformation &amp;&amp; req.responseHeaders) &#123;</span><br><span class="line"><span class="keyword">if</span> ([req.responseHeaders objectForKey:<span class="string">@"Location"</span>] ) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@" ### %s redirection URL ###"</span>, __func__);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//5.2如果不是重定向信息，则把需要用到的信息提取出来</span></span><br><span class="line">_contentInformation = [[RLContentInformationForASI alloc]init];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> numer = [[req.responseHeaders objectForKey:<span class="string">@"Content-Length"</span>]longLongValue];</span><br><span class="line">_contentInformation.contentLength = numer;</span><br><span class="line">_contentInformation.byteRangeAccessSupported = <span class="literal">YES</span>;</span><br><span class="line">_contentInformation.contentType = [req.responseHeaders objectForKey:<span class="string">@"Content-type"</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.3开始从请求中获取返回数据</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s before tempData length = %lu ###"</span>, __FUNCTION__, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.tempData.length);</span><br><span class="line">strongSelf.tempData = [<span class="built_in">NSMutableData</span> dataWithData:req.rawResponseData];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s after tempData length = %lu ###"</span>,__FUNCTION__, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.tempData.length);</span><br><span class="line"><span class="comment">//5.4把返回数据输出到loadingRequest中</span></span><br><span class="line">[strongSelf processPendingRequests];</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (req.succeed)&#123;</span><br><span class="line"><span class="number">6</span><span class="comment">//请求返回成功，在这里做最后一次把数据输出到loadingRequest，且做一些成功后的事情</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s succeed ###"</span>, __func__);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s tempData length = %lu ###"</span>, __func__, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.tempData.length);</span><br><span class="line">__<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"><span class="keyword">if</span> (strongSelf) &#123;</span><br><span class="line">[strongSelf processPendingRequests];</span><br><span class="line"></span><br><span class="line"><span class="number">7</span><span class="comment">//保存缓存文件，我在保存文件这里做了一次偷懒，如果有人参考我写的文件可对保存文件作改进，在每次返回数据时把数据追加写到文件，而不是下载成功之后才保存，这请求时也可以使用这个来实现断点重输的功能</span></span><br><span class="line"><span class="built_in">AVAResourceFile</span> *resourceFile = [[<span class="built_in">AVAResourceFile</span> alloc]initWithContentType:strongSelf.contentInformation.contentType date:strongSelf.tempData];</span><br><span class="line">[strongSelf.resourceFileManager saveResourceFile:resourceFile withURL:<span class="keyword">self</span>.resourceURL];</span><br><span class="line"><span class="number">8</span><span class="comment">//在此做一些清理缓存、释放对象和回调到上层的操作</span></span><br><span class="line">[strongSelf complete];</span><br><span class="line"><span class="keyword">if</span> (strongSelf.delegate &amp;&amp; [strongSelf.delegate respondsToSelector:<span class="keyword">@selector</span>(resourceLoader:didLoadResource:)]) &#123;</span><br><span class="line">[strongSelf.delegate resourceLoader:strongSelf didLoadResource:strongSelf.resourceURL];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (req.failed)&#123;</span><br><span class="line"><span class="comment">//9如果请求返回失败，则向上层抛出错误，且清理缓存等操作</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s failed ###"</span> , __func__);</span><br><span class="line">[<span class="keyword">self</span> completeWithError:req.error];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span>.pendingRequests addObject:loadingRequest];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第六步，把请求返回数据输出到loadingRequest的操作">第六步，把请求返回数据输出到loadingRequest的操作</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)processPendingRequests</span><br><span class="line">&#123;</span><br><span class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">__<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *requestsCompleted = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="number">1</span><span class="comment">//从缓存信息中找出当前正在请求中的loadingRequest</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">AVAssetResourceLoadingRequest</span> *loadingRequest <span class="keyword">in</span> strongSelf.pendingRequests)&#123;</span><br><span class="line"><span class="number">2</span><span class="comment">//把头部信息输出到loadingRequest中</span></span><br><span class="line">[strongSelf fillInContentInformation:loadingRequest.contentInformationRequest];      </span><br><span class="line"><span class="number">3</span><span class="comment">//把视频数据输出到loadingRequest中</span></span><br><span class="line"><span class="built_in">BOOL</span> didRespondCompletely = [strongSelf respondWithDataForRequest:loadingRequest.dataRequest];</span><br><span class="line"><span class="number">4</span><span class="comment">//在success状态中做最后一次调用的时候，检测到请求已经完成，则从缓存信息中清除loadingRequest，并且把loadingRequest标志为完成处理状态</span></span><br><span class="line"><span class="keyword">if</span> (didRespondCompletely)&#123;</span><br><span class="line">[requestsCompleted addObject:loadingRequest];</span><br><span class="line">[loadingRequest finishLoading];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span><span class="comment">//清理缓存</span></span><br><span class="line">[strongSelf.pendingRequests removeObjectsInArray:requestsCompleted];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">、</span><br><span class="line"></span><br><span class="line"><span class="comment">//把提取出来的头部信息输出到loadingRequest中，可以优化</span></span><br><span class="line">- (<span class="keyword">void</span>)fillInContentInformation:(<span class="built_in">AVAssetResourceLoadingContentInformationRequest</span> *)contentInformationRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (contentInformationRequest == <span class="literal">nil</span> || <span class="keyword">self</span>.contentInformation == <span class="literal">nil</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">contentInformationRequest.byteRangeAccessSupported = <span class="keyword">self</span>.contentInformation.byteRangeAccessSupported;</span><br><span class="line">contentInformationRequest.contentType = <span class="keyword">self</span>.contentInformation.contentType;</span><br><span class="line">contentInformationRequest.contentLength = <span class="keyword">self</span>.contentInformation.contentLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把缓存数据输出到loadingRequest中</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)respondWithDataForRequest:(<span class="built_in">AVAssetResourceLoadingDataRequest</span> *)dataRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> startOffset = dataRequest.requestedOffset;</span><br><span class="line"><span class="keyword">if</span> (dataRequest.currentOffset != <span class="number">0</span>)&#123;</span><br><span class="line">startOffset = dataRequest.currentOffset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don't have any data at all for this request</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.tempData.length &lt; startOffset)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is the total data we have from startOffset to whatever has been downloaded so far</span></span><br><span class="line"><span class="built_in">NSUInteger</span> unreadBytes = <span class="keyword">self</span>.tempData.length - (<span class="built_in">NSUInteger</span>)startOffset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Respond with whatever is available if we can't satisfy the request fully yet</span></span><br><span class="line"><span class="built_in">NSUInteger</span> numberOfBytesToRespondWith = MIN((<span class="built_in">NSUInteger</span>)dataRequest.requestedLength, unreadBytes);</span><br><span class="line"></span><br><span class="line">[dataRequest respondWithData:[<span class="keyword">self</span>.tempData subdataWithRange:<span class="built_in">NSMakeRange</span>((<span class="built_in">NSUInteger</span>)startOffset, numberOfBytesToRespondWith)]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> endOffset = startOffset + dataRequest.requestedLength;</span><br><span class="line"><span class="built_in">BOOL</span> didRespondFully = <span class="keyword">self</span>.tempData.length &gt;= endOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> didRespondFully;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>视频边下边播的流程大致上已经描述完毕，本博文中没有说到的代码有错误处理方式、缓存文件的读写和保存格式、部分内存缓存使用说明、</strong></p>
<p>参考链接：<br><a href="http://www.codeproject.com/Articles/875105/Audio-streaming-and-caching-in-iOS-using" target="_blank" rel="noopener">http://www.codeproject.com/Articles/875105/Audio-streaming-and-caching-in-iOS-using</a><br><a href="http://www.cnblogs.com/kenshincui/p/4186022.html#mpMoviePlayerController" target="_blank" rel="noopener">http://www.cnblogs.com/kenshincui/p/4186022.html#mpMoviePlayerController</a></p>
<p>补充：<br>在开发过程中遇到的一些坑在这里补充一下<br>1.在iOS9后，AVPlayer的replaceCurrentItemWithPlayerItem方法在切换视频时底层会调用信号量等待然后导致当前线程卡顿，如果在UITableViewCell中切换视频播放使用这个方法，会导致当前线程冻结几秒钟。遇到这个坑还真不好在系统层面对它做什么，后来找到的解决方法是在每次需要切换视频时，需重新创建AVPlayer和AVPlayerItem。<br>2.iOS9后，AVFoundation框架还做了几点修改，如果需要切换视频播放的时间，或需要控制视频从头播放调用seekToDate方法，需要保持视频的播放rate大于0才能修改，还有canUseNetworkResourcesForLiveStreamingWhilePaused这个属性，在iOS9前默认为YES，之后默认为NO。<br>3.AVPlayer的replaceCurrentItemWithPlayerItem方法正常是会引用住参数AVPlayerItem的，但在某些情况下导致视频播放失败，它会马上释放对这个对象的持有，假如你对AVPlayerItem的实例对象添加了监听，但是自己没有对item的计数进行管理，不知道什么时候释放这个监听，则会导致程序崩溃。<br>4.为什么我选择第三种方法实现边下边播，第一种方法需要程序引入LocalServer库，需增加大量app包大小，且需要开启本地服务，从性能方面考虑也是不合适。第二种方式存在的缺陷很多，一来只能播放网络上返回格式contentType为public/mpeg4等视频格式的url视频地址，若保存下来之后，文件的格式也需要保存为.mp4或.mov等格式的本地文件才能从本地中读取，三来使用AVMutableComposition对视频进行重构后保存，经过检验会对视频源数据产生变化，对于程序开发人员来说，需要保证各端存在的视频数据一致。第三种边下边播的方法其实是对第二种方法的扩展，能够解决上面所说的三种问题，可操控的自由度更高。</p>

      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/10/06/Video-streaming-and-caching-in-iOS/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/10/06/Video-streaming-and-caching-in-iOS/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/10/06/Video-streaming-and-caching-in-iOS/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-07-22T17:50:14.000Z"><a href="/2015/07/22/总结一些有用的iOS工具/">周三, 7月 22 2015, 10:50:14 上午</a></time>

  
    <h1 class="title"><a href="/2015/07/22/总结一些有用的iOS工具/">总结一些有用的iOS工具</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p><a href="http://fuckingclangwarnings.com/" target="_blank" rel="noopener">《Which Clang Warning Is Generating This Message》</a>：Clang 的警告与语义对照表。通过它可以更加方便地知道 Clang 的警告所表达的意思。</p>
<p><a href="http://swiftdoc.org/" target="_blank" rel="noopener">SwiftDoc</a>：SwiftDoc是一个在线的Swift帮助文档。</p>
<p><a href="http://neilpa.me/rac-marbles/#merge" target="_blank" rel="noopener">RAC函数使用交互图</a>：列出Reactive Cocoa中常用函数的交互图</p>
<p><a href="http://www.osstatus.com" target="_blank" rel="noopener">OSStatus</a> 苹果底层错误码原因查询</p>
<p><a href="https://www.hex-rays.com/products/ida/index.shtml" target="_blank" rel="noopener">IDA</a> 支持Win、Linux、Mac OS的多平台反汇编器，有免费试用版</p>
<p><a href="http://revealapp.com/" target="_blank" rel="noopener">Reveal</a> 能分析app UI布局，有点类似苹果自带的布局分析工具，但这个工具能够使用在逆向工程中帮助你分析界面层次，官网没有提供免费的版本，需自行寻找破解版本</p>
<p><a href="http://www.i-funbox.com/" target="_blank" rel="noopener">iFunBox</a> iOS文件管理工具，免费工具</p>
<p><a href="http://www.charlesproxy.com/" target="_blank" rel="noopener">Charles</a> 网络抓包分析修改工具,可免费可收费</p>
<p><a href="http://www.navicat.com/store/navicat-premium" target="_blank" rel="noopener">Navicat Premium</a> 数据库管理工具，官网收费，自行寻找破解版</p>
<p><a href="https://kapeli.com/dash" target="_blank" rel="noopener">Dash</a> 文档管理工具，免费，可下载所有语言文档</p>
<p><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">Source Tree</a> git管理工具，免费</p>
<p><a href="http://astah.net/editions/community" target="_blank" rel="noopener">astah community</a> 绘制UML图</p>
<p>[class-dump] iOS逆向中用于导出Mach-O文件的头部信息</p>
<p>持续更新…</p>

      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/07/22/总结一些有用的iOS工具/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/07/22/总结一些有用的iOS工具/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/07/22/总结一些有用的iOS工具/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-14T21:58:20.000Z"><a href="/2015/06/14/Dynamic-Library-Usage-Guidelines/">周日, 6月 14 2015, 2:58:20 下午</a></time>

  
    <h1 class="title"><a href="/2015/06/14/Dynamic-Library-Usage-Guidelines/">Dynamic Library Usage Guidelines</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        间接寻址是一种代码生成技术的名字，它允许被定义在文件中的symbols能够被另外一个文件引用，并且不需要引用文件知道任何有关定义这些symbol文件的布局。因此，定义文件能够被独立地修改。间接寻址最小化了动态链接器需要修改的地址，这回提高代码分享和提高效率......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/14/Dynamic-Library-Usage-Guidelines/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/14/Dynamic-Library-Usage-Guidelines/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/14/Dynamic-Library-Usage-Guidelines/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-12T00:31:02.000Z"><a href="/2015/06/11/Overview-of-Dynamic-Libraries/">周四, 6月 11 2015, 5:31:02 下午</a></time>

  
    <h1 class="title"><a href="/2015/06/11/Overview-of-Dynamic-Libraries/">Overview of Dynamic Libraries</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        决定app性能的两个重要因素是他们的启动时间和他们的内存跟踪。当程序运行时减少一个app的执行的文件的大小和最少化它内存的使用率会使app更快地启动并且使用更少的内存。使用动态库来代替静态库回减少一个app执行文件的大小。他们同样也能让app去在加载库被需要时才加载库的特定功能，而不是在他们启动的时候就被加载。这个特性能够减少启动时间和让内存更有效地利用......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/11/Overview-of-Dynamic-Libraries/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/11/Overview-of-Dynamic-Libraries/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/11/Overview-of-Dynamic-Libraries/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-10T22:54:40.000Z"><a href="/2015/06/10/position-independent-code/">周三, 6月 10 2015, 3:54:40 下午</a></time>

  
    <h1 class="title"><a href="/2015/06/10/position-independent-code/">位置独立代码</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        位置独立代码（Position-independent code)，是在PowerPC环境代码生成技术的名字，它允许动态链接器在不固定的虚拟内存地址中加载一个区域代码。除了位置独立代码生成的一些形式之外，操作系统会把你希望共享的代码放置在虚拟内存固定地址中，这会导致维护操作系统时相当困难。例如，它基本不会支持shared libraries和frameworks，因为他们都需要预先分配一个永远不会变的地址......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/10/position-independent-code/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/10/position-independent-code/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/10/position-independent-code/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-10T22:54:28.000Z"><a href="/2015/06/10/indirect-addressing/">周三, 6月 10 2015, 3:54:28 下午</a></time>

  
    <h1 class="title"><a href="/2015/06/10/indirect-addressing/">间接寻址</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        间接寻址是一种代码生成技术的名字，它允许被定义在文件中的symbols能够被另外一个文件引用，并且不需要引用文件知道任何有关定义这些symbol文件的布局。因此，定义文件能够被独立地修改。间接寻址最小化了动态链接器需要修改的地址，这会提高代码分享和提高效率......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/10/indirect-addressing/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/10/indirect-addressing/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/10/indirect-addressing/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-07T18:03:15.000Z"><a href="/2015/06/07/loading-code_at-runtime/">周日, 6月 7 2015, 11:03:15 上午</a></time>

  
    <h1 class="title"><a href="/2015/06/07/loading-code_at-runtime/">在运行时加载代码</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        你可能需要用到动态分享库，它能够保存可重用代码，在多个程序使用时有函数的使用优势。例如，当你开发Cocoa应用程序时，你的程序最少会链接Foudation和Application Kit框架。通过这个实践，当你的应用程序用户更新电脑系统软件框架时，你的程序能够自动利用那些改进的框架......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/07/loading-code_at-runtime/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/07/loading-code_at-runtime/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/07/loading-code_at-runtime/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src>
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-07T15:47:09.000Z"><a href="/2015/06/07/executing-mach-o-file/">周日, 6月 7 2015, 8:47:09 早上</a></time>

  
    <h1 class="title"><a href="/2015/06/07/executing-mach-o-file/">运行Mach-O文件</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        为了展示代码的效果，程序必须启动线程和链接到dynamic shared libraries（动态分享库），为了与其它库和模块一起运行，你的应用程序必须在modules(.o)里面定义符号的引用，这些引用会在运行时被解决。在运行时应用程序中所有modules的symbol名字都会在共享的命名空间中使用。为了允许未来应用程序和使用库的使用，应用程序和库的开发者必须保证他们在功能和数据中选择的名字不会与其它modules冲突......
      
    </div>
    <footer>
      
        <div class="	">
            <a href="/2015/06/07/executing-mach-o-file/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://sky-weihao.github.io/2015/06/07/executing-mach-o-file/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/07/executing-mach-o-file/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一页<i class="fa fa-long-arrow-right"></i></a>
  
  <div class="clearfix"></div>
</nav>

<script src="/js/jquery.anystretch.min.js"></script>
<script src="/js/cover.js"></script>

    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div>
  
  &copy; 2019 Weihao Xu
  
</div>
Powered by <a href="http://zespia.tw/hexo/" title="Hexo" target="_blank" rel="noopener">Hexo</a> and <a href="http://pages.github.com/" title="GitHub Pages" target="_blank" rel="noopener">GitHub Pages</a>

<div class="clearfix"></div></footer>
  
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js"></script>




    <script type="text/javascript">
        (function(){
                    $("#main-nav").removeClass('normal_mode').addClass('top_mode');
/*
            $(window).scroll(function(){

                var scrollTop = $(window).scrollTop();
                if ( scrollTop > 0 ){
                    $("#main-nav").removeClass('normal_mode').addClass('top_mode');
                } else{
                    $("#main-nav").removeClass('top_mode').addClass('normal_mode');
                }

            });
*/
        })();
    </script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
  (function($){
    $('.fancybox').fancybox({
      'titlePosition': 'inside'
    });
  })(jQuery);
  </script>



    
    <script type="text/javascript">
      var duoshuoQuery = {short_name:"sky-weihao"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = 'http://static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] 
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>



<script type="text/javascript">
  
  $(function(){

    $('.title').hover(
      function() {      
        $(this).stop().animate(
          {'marginLeft': '10px'}, 200
        );   
      }, 
      function() {       
        $(this).stop().animate({'marginLeft': '0px'}, 200);      
      
    });   

  });

</script>


</body>
</html>