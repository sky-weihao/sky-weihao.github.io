<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Sky-Weihao的博客</title>
  <meta name="author" content="Weihao Xu">
  
  <meta name="description" content="我是文化宫啊文化宫,欢迎光临我的博客">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Sky-Weihao的博客"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/avatar.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Sky-Weihao的博客" type="application/atom+xml">
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-368771XX-X']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>

<body>
  <header id="header" class='normal_mode'>
    <nav id="main-nav">
  <ul class='container'>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">文档</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
  </header>
  <div id="content" class="container">
    <div id="cover">
	<div id="profile" alt="http://ww1.sinaimg.cn/large/6cea169fjw1edgyzma1xcj21kw16ohba.jpg">
		<a href="/">
			<div class="logo">
				<img src="/avatar.png" alt="Profile Picture">
			</div>
			<div id="title">Sky-Weihao的博客</div>
		</a>

		
			<div id="subtitle">欢迎光临寒舍</div>
		
		 <ul class="my-socials">
  
  <li>
  	<a href="https://github.com/sky-weihao" class="github" target="_blank">
  		<i class="fa fa-github"></i>
  	</a>
  </li>
  
  <li>
  	<a href="http://weibo.com/1867935643/profile" class="weibo" target="_blank">
  		<i class="fa fa-weibo"></i>
  	</a>
  </li>
  
 
 <li>
   	<a href="mailto:jmepxwh@gmail.com" class="email" target="_blank" title="Email Me">
  		<i class="fa fa-envelope"></i>
  	</a>
 </li>
 
</ul>
	</div>
</div>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-07T00:47:09.000Z"><a href="/2015/06/07/executing-mach-o-file/">周日, 6月 7 2015, 8:47:09 早上</a></time>

  
    <h1 class="title"><a href="/2015/06/07/executing-mach-o-file/">运行Mach-O文件</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>为了展示代码的效果，程序必须启动线程和链接到dynamic shared libraries（动态分享库），为了与其它库和模块一起运行，你的应用程序必须在modules(.o)里面定义符号的引用，这些引用会在运行时被解决。在运行时应用程序中所有modules的symbol名字都会在共享的命名空间中使用。为了允许未来应用程序和使用库的使用，应用程序和库的开发者必须保证他们在功能和数据中选择的名字不会与其它modules冲突。<br>OX 10.1之后的双重命名空间特征把module的名字作为symbols表symbol名字的一部分添加到表里面去。这种方法确保一个module的符号名字不会与其它module的名字冲突。（然而这段的后面半段我也不知道跟前半段有什么关系。）为了展示独特的任务或者提高用户的体验，你的程序可能需要启动其它的应用程序或者运行命令行工具。为了维护高等级的操作性和提供一致的用户体验，你的应用程序需要使用特定的系统功能和框架去运行线程和运行程序。<br>这篇文章提供了OS X动态加载过程的概览，OS X中加载和链接一个程序的过程主要有两个入口：OS X 的内核和动态链接器。当你执行一个程序，内核会为程序创建处理进程，然后在程序地址空间中加载程序和动态链接器shared librariy，通常是/usr/lib/dyld。然后内核会执行动态链接器中加载库和程序引用的代码。这篇文章同样也描述了module中依赖于他们如何被定义的可视symbols和在运行时解决symbol的过程。</p>
<h2 id="Launching_an_application">Launching an application</h2><p>当你从Finder中启动一个应用程序时，又或者当你在shell中运行程序时，系统最后会根据你的行为调用两个函数，fork和execve。fork功能创建一个进程；execve功能加载和运行程序。这里有多个不同的功能，比如execl,execv和exect，每个功能提供了不同传参和环境变量的方法到程序中。在OS X，每个这些其他的exec路径最终调用了内核路径execve。<br>当你在写Mac的app时，你会使用到Launch Services框架启动其它应用程序。Launch Services知道程序的包，并且你能够使用它打开应用程序和文档。然后Finder和Dock使用Launch Services去维护从文档类型反射到能打开它们（文档）的程序的数据库(如你想打开一个.md文件，开始数据库中是没有打开它的程序的资料，但是当你第一次选择打开它的程序时，数据库会保存能够打开.md文件的程序的数据)。Cocoa应用程序能使用类NSWorkspace启动程序和文档，NSWorkspace它本身使用了Launch Services。Launch Service最终还是调用到了fork和exec去做实际的执行代码和创建新线程。For more information on Launch Services, see <a href="https://developer.apple.com/library/mac/documentation/Carbon/Conceptual/LaunchServicesConcepts/LSCIntro/LSCIntro.html#//apple_ref/doc/uid/TP30000999" target="_blank" rel="external"> Launch Services Programming Guide</a></p>
<h2 id="Finding_imported_Symbols">Finding imported Symbols</h2><p>当动态链接器加载一个Mach-O文件，它会链接文件的imported symbols到他们在share library或framework中的定义。这一段描述了如何绑定一个Mach-O imported symbols到他们在其它Mach-O文件里的定义。它同样解释了查找symbol的过程。</p>
<h3 id="Forking_and_executing_the_process">Forking and executing the process</h3><p>Mach-O执行文件包含由加载命令组成的头部，对于使用了shared libraries或者frameworks的程序来说，这些<strong>加载命令每个都定义了linker需要用到去加载程序的位置</strong>。如果你使用了xcode，linker一般是/usr/lib/dyld.<br>当你调用execve方法，内核首先会加载特定的程序文件（Mach－O文件）并且检查在文件中mach_header的结构。<strong>内核证明文件是有效的Mach－O文件，截获在header中的加载命令，然后内核加载指定的动态链接器加载命令到内存中并且在程序文件中运行动态链接器。</strong><br><strong>动态链接器加载所有主程序需要链接的shared libraries和绑定足够的符号去启动程序</strong>。然后调用入口函数，在构建时期，静态链接器从对象文件/usr/bin/crtl.o添加标准的入口函数到主执行文件中。这个功能为内核设置了运行时环境状态并且为c++对象调用静态初始器，初始化Objective-C运行时，并且调用程序的main函数。（即crtl.o文件是程序主要入口，这个入口调用main函数）。</p>
<h3 id="Binding_Symbols">Binding Symbols</h3><p>绑定是解决一个module中对其它modules的函数和数据引用的解决过程。modules可以使用在相同或者不同的Mach-O文件中。当程序第一次加载的时候，动态链接器加载imported shared libraries到程序的地址空间中。当绑定执行时，链接器会用shared libraries中实际定义的内存地址代替执行文件中的imported reference.<br>动态链接器能在加载和执行时期的不同阶段绑定程序，它们依赖于你在构建期定义的选项：</p>
<ol>
<li>Just-in-time binding，动态链接器在当程序第一次使用reference的时候绑定reference。链接器根据程序什么时候被加载去读取shared libraries。然而，动态链接器不会绑定程序的符号引用直到这个符号被使用了。</li>
<li>load-time binding 在加载程序时绑定所有imported reference</li>
<li>prebinding load-time binding的一种形式，每个shared libraries被程序在特定的地址预绑定了。</li>
<li>weak references在OX X10.2被引入，用作在一些系统上可用但在另外一些系统上不可用的可选实现功能。<br>如果没有使用任何参数的话，系统会默认设置参数为 just-in-time binding。</li>
</ol>
<h3 id="Searching_for_Symbols">Searching for Symbols</h3><p>一个symbol是一个通常代表了可执行文件的函数、数据变量或者常量的位置，程序中函数和数据的引用是对symbol的引用。当使用动态链接器路由时，为了引用一个symbol，你通常会传symbol的名字，虽然一些功能也会接受一串代表symbol顺序的数字。symbol的名字代表了一个遵循标准C调用规则的函数是函数的名字加上一个强调的前缀。（如函数名字为addNum，则symbol的名字可能为_addNum）。因此，代表main函数对应的symbol名字是_main.</p>
<p>通过OSX v10.0开发工具创建的程序从所有加载的share libraries中添加所有的symbols到一个global list中。你程序中引用的任何symbol能够被定为在任意shared library中，因为shared library是程序的独立库。<br>OS X v10.1介绍了两级symbol命名空间特性，第一级命名空间是包含这个symbol的library，并且第二级是symbol的名字，一旦二级命名空间特性被使用且静态连接器记录imported symbols的引用时，它会记录包含symbol库的名字和symbol的名字。使用两级命名空间特性比单个命名空间多了两个优点：</p>
<ol>
<li>提高查找symbols的效率，使用两级命名空间时，动态链接器确切知道从哪里开始查看symbol的实现，使用单个命名空间时，动态链接器必须查找所有所有的加载库。</li>
<li>提高向前兼容性。在单个命名空间，两个或者其它的库不能包含不同实现的但名字相同的symbol，因为动态链接器不能知道哪个library含有需要的实现。这个不是开始就出现的问题，因为静态链接器会在你第一次构建这个程序时找出所有这些问题，然而，如果你其中一个独立shared libraries之后release一个新版本的包含与你现在程序中的shared library相同symbol的版本库时，你的程序会失败运行。</li>
</ol>
<p>你的程序必须直接链接到包含symbol的shared library。（或者，如果库是unbrella framework的一部分，会链接到包含它的umbrella framework）。<br>当获得使用二级命名空间特性的程序构建的symbols时，你必须定义包含shared libraries的symbols的引用。<br>对于没有两级命名空间的程序来说，你能够告诉链接器去定义undefined symbols的引用，即使编译器不能找到包含他们的库。当你构建一个有这些undefined symbols的执行文件时，你正在假设一个其它的文件被作为执行文件在运行时被加载。Bundles 和shared libraries有时用了这个选项去引用被定义在主执行文件中的的symbol。然而，这会导致你没有二级命名空间中优化和兼容性的好处。通常来说直接链接一个定义了引用的执行文件会更好。然而，如果你必须链接undefined references.你能通过运行单命名空间特性和忽略undefined reference warning，通过使用选项-flat_namespace和-undefined suppress，如使用下面的命令行代码：<br>ld -o my_tool -flat_namespace -undefined suppress peace.o love.o<br>当使用两级命名空间构建执行文件且如果程序时面向OS X v10.3或者以后，你能够允许剩余的undefined symbols被动态链接器查找。为了使用这个特性的优点，使用-undefined dynamic_lookup 选项。<br>为了构建两级命名空间的执行文件，静态连接器必须能够查找每个symbol的源库。这会产生一个困难给bundles的作者和被设为单命名空间的dynamic shared libraries。为了成功构建两级命名空间，要保持下面的点：</p>
<ol>
<li>Bundles中需要引用定义在程序主执行文件中的symbols必须使用-bundle_loader 静态链接器选项。静态链接器然后能为undefined symbols查找主执行文件。</li>
<li>Shared libraries中需要引用定义在程序主执行文件中的symbols必须使用没有在库引用中使用的函数动态地加载symbol，如disym或者NSLookupSymbolInImage。<br>注意：一个两级symbol命名空间能够通过使用单级symbol命名空间函数搜索。<br>你可以使用nm(1)命令去输出执行文件中的symbol表<br><img src="./executing_img_1.png" alt="输出中间对象文件的symbol表"><br><img src="./executing_img_2.png" alt="输出out文件的symbol表"><h2 id="Scope_and_Treatment_of_Symbol_Definitions">Scope and Treatment of Symbol Definitions</h2>在对象文件中的符号可能存在于多个范围层次中，下面描述每个符号可能被定义的范围，并且提供c的创建不同符号类型的样本代码。</li>
<li>defined external symbol. 一个被定义的 external symbol是在当前对象文件中任意被定义的符号，包含functions和data。下面的代码定义了external symbols。<br>int x = 0;<br>double y = 99;</li>
<li>undefined external symbol是定义在当前文件外的任意符号，下面代码定义了两个外部符号，一个变量和一个函数,如下：<br>extern int x;<br>extern void someFunction<br>声明一个OC的属性时会产生两个方法，如：<br>@property NSString <em>text;<br>会产生- (void)setText:(NSString </em>)text;和-(NSString *)text;<br>会产生两个外部符号<br>(__TEXT,__text) non-external -[NSObject setText:]<br>(__TEXT,__text) non-external -[NSObject text:]</li>
<li>common symbol，这个符号是指可能出现在多个中间对象文件，静态链接器在多个输入文件中展示多个共同的符号定义，并且复制其中最大容量的到最终的程序中。当c编译器发现一个全局变量没有初始化方法并且没有extern标示时，产生一个common symbol<br>int x;</li>
<li>private external symbol是一个不能被其它modules发现的symbol，如<br>static int x；<br>private external symbol是一个defined external symbol，它只能被在相同对象文件中的其它modules发现。标准的静态链接器改变private symbols成private defined symbols（除非你用-keep<em>private<em>externs选项标识了它）。<br>你能够通过_<em>private<em>extern<strong>关键字或者visibility(“hidden”)属性去定义一个symbol为private external symbol，如：
</strong>private_extern</em></em> int x = 9; c only<br>int y = 99 __attribute</em></em>((visibility(“hidden”))); c and c++ ,GCC 4.0 only。<br>在OC中类的实例变量NSString *text;</li>
<li>coalesced symbol是一个可能在多个对象文件中被定义的，但是静态连接器只会在输出文件中产生一个复制。这样能省下大量的内存，如编译器必须为每个对象文件产生的C++语言特性，如虚函数表，运行时类型消息和c++模版实例化。编译器会决定哪个结构应该被聚合，你不需要做任何工作。</li>
<li>weak reference是一个undefined external symbol，它没必要为了程序成功链接而被找到，如果smybol不存在，动态链接器会设置这个symbol的地址为0。文件的weak references能够被使用在10.2之后。接下来的c代码描述了使用weak reference后可选的api调用：<br>if ( SomeNewFunction != NULL)<br>SomeNewFunction();<br>为了标示功能应该是作为weak reference对待的，使用weak<em>import属性作为函数类型，如下所述：<br>void SomeNewFunction(void) <em>_attribute</em></em>((weak_import));</li>
<li>debugging symbol时编译器产生的一个符号，它允许调试器从机器码的地址反射到源代码的位置。标准的编译器产生了debugging symbols使用了Stabs格式或者SWARF格式。当使用Stabs格式，debugging symbols和其它symbols一样，都被保存在symbol表。如果使用DWARF格式，debugging symbols被保存在特定的segment:__DWARF segment。<br>使用DWARF格式，你同样需要选择保存debugging symbol在一个分割的debug-information文件，这会当你在允许全部的测试方式时减少二进制文件的大小。可使用dwarfdump命令输出调试信息。</li>
</ol>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/06/07/executing-mach-o-file/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="/2015/06/07/executing-mach-o-file/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/07/executing-mach-o-file/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-05T10:37:57.000Z"><a href="/2015/06/05/executable_mach_o_file/">周五, 6月 5 2015, 6:37:57 晚上</a></time>

  
    <h1 class="title"><a href="/2015/06/05/executable_mach_o_file/">可执行文件Mach-O的详细结构，运行该文件时是如何加载进行时，如何链接和加载动态库和静态库</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>在Mach-O文件的开头，有一个header结构标记这个文件的类型为Mach-O文件，并且这个结构里面包含了一些其它的信息：如target architecture和其它文件解析的选项等。<br>header结构后面紧接着是一串关于layout和链接文件特征的加载命令，除了一些其他消息外，这些加载命令定义了：</p>
<ol>
<li>在虚拟内存中的初始化布局文件</li>
<li>symbol 表的地址（$可是使用nm(1)工具去查看里面的内容）</li>
<li>程序主线程的初始执行状态</li>
<li>包含主要可执行的imported symbols的共享库</li>
</ol>
<p>在这些加载命令之后，所有的Mach-O文件包含了一个或多个segments的数据，每一个segment都包含一个或多个的sections，每个section包含一些独特类型的代码或数据。每一个segment定义了虚拟内存的一个区域，这个区域被动态连接器映射到程序的内存地址。segment和section的实际数量和布局是被上面的加载命令和文件类型确定产生的。<br>     在用户级别的完全链接的Mach-O文件，最后一个segment是__LINKEDIT段，这个段包含了链接编译信息的表，如symbol 表、string表等，他们被用于动态加载器对可执行文件或Mach-O bundle和他们所依赖的库进行链接<br><img src="./img/Screen Shot 2015-05-25 at 10.23.29 PM.png" alt=""></p>
<h2 id="头结构和加载命令">头结构和加载命令</h2><p>一个Mach-O文件包含了一个结构的代码和数据，一个Mach-O文件头结构定义了能让内核去查看的targer architecture，例如基于PowerOC电脑的代码不能再基于Intel的电脑上执行，可以使用下面命令查看头结构<br>xcrun otool -v -h a.out<br><img src="./img/Screen Shot 2015-05-22 at 5.57.28 PM.png" alt=""></p>
<p>可使用下面命令查看加载命令<br>xcun otool -v -l a.out<br><img src="./img/Screen Shot 2015-06-05 at 5.39.28 PM.png" alt=""></p>
<h3 id="DATA">DATA</h3><h4 id="Segment">Segment</h4><p> 一个segment定义了一些Mach-O文件的数据、地址和内存保护属性，这些数据在动态链接器加载程序时被映射到了虚拟内存中。因此，segments通常都是虚拟内存页对齐的，一个segment包含了0或多个sections。<br>segments在运行时需要的内存比他们在编译时更多，而且他能定义比他们实际在硬盘空间大小中更多的内存空间。例如，链接器产生给PowerPC的可执行文件<strong>PAGEZERO segment在虚拟内存中的大小是一页，但是在硬盘中大小为0，因为 </strong>PAGEZERO 没有数据，所以它没有必要在可执行文件中占有任何空间。<br>为了压缩，中间对象文件（）包含一个segment。这个segment没有名字，它包含了在最终对象文件中所有最终会分到不同segment的sections数据。这些数据结构中定义了一个section在segment中的名字和地方，然后静态链接会把每个section在最后对象文件中放到不同的segment中去。<br>为了规范，segment应该在虚拟内存页面边界上对齐，4096个字节。为了计算segment的大小，把每段的大小给加起来，然后以这个总大小在虚拟内存中取整4096字节的倍数。<br> 头结构和加载命令在可执行文件中因为分页的原因。被当成是第一个segment的部分。<br>下列这些是标准OS X的开发工具可能在可执行文件中包含的segments，其中包括：</p>
<ol>
<li>静态连接器创建了<strong>PAGEZERO segment作为可执行文件的第一段，这个segment在虚拟内存中位置为0x00000000并且没有确保是内存对齐的，因此造成访问NULL指针（一个会导致马上崩溃的通用c程序错误）。这个segment在现在的程序结构中充满了一整页的虚拟内存，即4096个字节，因为在</strong>PAGEZERO segment中没有数据，所以他在文件中没有占有空间（在segment command中文件大小为0）。</li>
<li>__TEXT segment包含了可执行代码和其他只读的数据，为了允许内核把它直接从可执行文件映射到可共享内存，静态连接器设置了这一段的虚拟内存不允许执行写操作。当这段命令映射到内存中时，他能够被所有对这段内容感星期的进程访问（这个最开始被用作frameworks，bundles和共享的库，但是它也可能在OS X中同时运行多份同样的可执行复制文件）。只读的属性也意味着__TEXT segment的数据永远不需要重新写回硬盘中。当内核需要释放物理内存时，它只需要废弃掉那些__TEXT的内存页并且当需要的时候重新从硬盘中加载。</li>
<li>__DATA segment包含了可写数据，静态链接器设置这段的虚拟内存允许读和写操作。因为它是可写的，一个框架或其他共享库的__DATA 段被每个链接到该库的进程复制一份。因为__DATA段的内存页被设置为可写可读的，内核会标记他们为在写的时候会被服务，因此当一个进程写了__DATA段的其中一页时，进程会收到那一页的复制数据。</li>
<li>__OBJC段包含了在Objective-C语言运行时支持库的数据</li>
<li>__IMPORT段包含了在可执行文件中的没有被定义的符号集合和非lazy的指向符号的指针。</li>
<li>__LINKEDIT段包含了动态链接器的原始数据，如符号，字符串和重定位的表的入口。</li>
</ol>
<h4 id="Section">Section</h4><p>__TEXT和__DATA段可能包含了一系列的标准sections。__OBJC segment包含了一系列的是Objective-C编译器私有的段。需要知道的是静态链接器和文件分析工具会使用section的类型和数据去定义它们如何处理section。</p>
<h5 id="__TEXT_segment">__TEXT segment</h5><p>__text section 有可执行的机器码，编译器只会把可执行的代码放到这一个section，没有其它任何形式的表或者数据。<br>__cstring section c的字符串常量，静态链接器会在构造最终的程序时把c的字符串常量合并（删除冗余的常量）<br>__picsymbol_stub 独立位置的间接符号集合Position-Independent Code” in Mach-O Programming Topics<br>__symbol_stub 间接符号集合<br>__const 初始化的常量变量，编译器会把所有声明为const的不能重定位的数据放到这里。（编译器会把未初始化的常量变量放到__zero-filled section中<br>__literal4 编译器会把单精度的浮点数放到这个section<br>__literal8 编译器会把双精度的浮点数放到这个section</p>
<p><strong>DATA segment
</strong>data 初始化的可变变量，如可写的c字符串和数据数组等。<br><strong>la_symbol_ptr lazy的符号指针，间接引用了被import到不同文件的功能函数
</strong>nl_symbol_ptr 非lazy的符号指针，间接引用了被import到不同文件的数据项（See “Position-Independent Code” in Mach-O Programming Topics for more information.）<br><strong>dyld 动态链接器的的占位符段，好像然而并没什么用
</strong>const 初始化的可重定位的常量变量<br><strong>module_init_func module的初始化函数，c++编译器会把静态构造器放到这里。
</strong>bss 未初始化的静态变量，如static int i<br>__common 未初始化的被import的符号定义，如被定义在全局范围中的int i;</p>
<p><strong>IMPORT
</strong>jump_table 在动态库中调用函数的符号集合<br>__pointers 非lazy的符号指针，这些用于直接引用被import到不同文件的功能函数</p>
<p>可以使用xcrun size -x -l -m a.out命令查看有哪些数据段<br><img src="./img/Screen Shot 2015-06-05 at 5.47.23 PM.png" alt=""></p>
<h3 id="Data_Types">Data Types</h3><p><a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/MachORuntime/index.html#//apple_ref/doc/uid/TP40000895" target="_blank" rel="external">详情查看 OS X ABI Mach-O File Format Reference</a></p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/06/05/executable_mach_o_file/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="/2015/06/05/executable_mach_o_file/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/05/executable_mach_o_file/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-05T10:36:57.000Z"><a href="/2015/06/05/building_mach_o_file/">周五, 6月 5 2015, 6:36:57 晚上</a></time>

  
    <h1 class="title"><a href="/2015/06/05/building_mach_o_file/">构建Mach-O文件</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，苹果文档翻译/">博客，苹果文档翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <h2 id="构建和运行Mach-O文件的工具">构建和运行Mach-O文件的工具</h2><p>为了在运行时展示实际加载和绑定程序的工作，内核会使用动态链接器（一个路径在/usr/lib/dylib被标记为dynamic shared library的工具）。内核会在新的线程中加载程序和动态链接器并且运行他们。<br>     通过这些文件，下面的工具会被抽象地介绍：</p>
<ol>
<li>编译器是一个把高级语言源代码转换成中间对象文件的工具，中间对象文件中包含了机器二进制代码和数据。没有特别情况的话，这边文章会默认把编译器默认当成是机器语言的assembler（把汇编语言转化成机器语言）。</li>
<li>静态链接器是一个把中间对象文件组合成最终产品程序的工具。</li>
</ol>
<p>Xcode工具包含了几个命令行工具用作于构建和分析你的应用程序，其中包括编译器和ld（静态链接器）。当你使用xcode时，这些标准的命令行工具或者一些第三方的工具被设置成xcode开发过程中的底层实现。以下列出标准的工具：</p>
<ol>
<li>compiler driver,/usr/bin/gcc，它支持的功能有编译、汇编和把c、c++，oc源代码模块链接在一起。编译器驱动调用了其他一些能够实际实现编译、汇编和静态链接功能的工具。实际工作的这些工具的实现细节被编译器驱动隐藏起来，他们的作用是把输入的高级语言源代码转化成汇编语言，然后这些汇编语言是作为assembler的输入。</li>
<li>c++的编译器驱动,/usr/bin/c++，功能像gcc，但是会自动链接c++的运行时功能到输出文件中（这样做是为了支持exceptions，运行时类型的消息和其它先进的语言特性）</li>
<li>assembler，/usr/bin/as，从汇编语言代码中创建中间对象文件，它最开始是被用于compiler driver中，编译驱动会把实际编译器产生的汇编语言源代码输出到assembler中。</li>
<li>静态连接器，/usr/bin/ld，作为一个独立的工具被编译器驱动使用作于整合Mach-O的可执行文件（在生成.o中间对象文件后使用）。你能够使用静态连接器去静态地或动态地去绑定程序。静态绑定程序完全是系统自身的事情，他们除了能调用系统框架和分享库外之外不能调用别的东西。在OS X中，内核扩展时被静态地绑定的，但是其它所有的程序类型是被动态绑定的，甚至是传统的UNIX和BSD的命令行工具也是动态绑定。所有在内核外通过程序对OS X内核的调用都是通过shared libraries的，而且只有动态绑定的程序能够访问shared libraries。（为什么静态链接器能够动态地去绑定程序，需要弄清这个概念）<br>6.library creation tool，/usr/bin/libtool，可以依赖参数创建静态压缩库（.a）和动态分享库（dynamic shared libraries, .dylib），libtool取代了一个老的工具ranlib。当构建shared libraries时，libtool调用了静态链接器ld。</li>
</ol>
<p>分析Mach-O文件的分析工具有以下几个：</p>
<ol>
<li>/user/bin/lipo lipo命令允许你创建和分析包含多个架构映射的二进制文件。其中一个二进制文件的例子是universal binary.Universal binaries能够被基于PowePC的基于Intel的苹果电脑使用。</li>
<li>/user/bin/file 显示文件的类型，对于多个架构的文件，它显示组成archive的每种反应的类型。</li>
<li>对象文件展示工具,/usr/bin/otool，展示Mach-O文件里的每个特定sections和segments的内容，它包含每个支持架构的符号反编译器(symbolic disassemblers)，并且它知道如何格式化大多数通用section类型的内容。</li>
<li>page分析工具，/usr/bin/pagestuff，展示每一个组成反射(image)的每个逻辑页面的内容，其中包含了sections的名字和每个page里的符号。这个工具不能在有多个架构的包含映射的二进制文件中运行。</li>
<li>symbol table的展示工具，/usr/bin/nm，允许你查看对象文件符号表的内容。</li>
<li>dwarfdump 用于调试时使用，导出DWARF的测试信息，如uuid或反编译测试数据</li>
<li>atos 也是调试时使用，转换数字化的地址信息到进程或二进制映射中的symbols</li>
<li>size 输出任意一个对象文件的任意section的大小</li>
</ol>
<h2 id="你能够构建Mach-O文件的类型">你能够构建Mach-O文件的类型</h2><p>在OS X中，一个典型的应用程序的可执行代码时源自于多个类型的文件。主要的可执行文件通常包含了程序的核心逻辑，如main函数的入口。程序的主要功能通常被主要执行文件的代码实现。，而其它的包含可执行代码的文件有：</p>
<ol>
<li>中间对象文件，这些文件不是最终产品，他们是更大的对象文件的基本构建快，编译器会从每一个输入高级源代码文件中产生输出的代码和数据到中间对象文件中，你能够使用静态链接器去整合对象文件到动态链接器。</li>
<li>dynamic shared libraries.这些文件包含能在应用程序中动态引用的可重用执行代码模块，并且他们会在程序启动时时被动态链接器动态加载，shared libraries通常被用作能被多个应用程序使用的大量代码。 See Using Shared Libraries and Frameworks in Loading Code at Runtime</li>
<li>Frameworks，这些目录包含了shared libraries和有关的资源，如图片文件，开发文档和程序接口等。See Using Shared Libraries and Frameworks in Loading Code at Runtime</li>
<li>Unbrella frameworks。这些事frameworks的的特殊类型，它们含有一个或多个sub framework。例如，Cocoa umbrella framework包含了Application Kit framework和Foundation framework. See Using Shared Libraries and Frameworks in Loading Code at Runtime.</li>
<li>static archive libraries（静态归档库），这些文件包含了静态链接器在构建期间能加入到应用程序的可重用代码模块。静态归档库通常含有只会被少量应用程序使用的非常少量的代码，或者由于某些原因很难在shared libraries中被维护的代码。See Static Archive Libraries。</li>
<li>Bundles。这些是程序在运行时使用动态链接功能加载的执行文件，Bundle实现了插件功能，如文字处理器的文件格式输入，bundle这个术语在OS X中有两个相关的意思：一是含有执行代码的实际对象文件。而是含有对象文件和相关资源的目录。See Loading Plug-in Code With Bundles in Loading Code at Runtime for more information</li>
<li>内核扩展被静态绑定到了Mach-O文件，它们类似于bundles被打包封装。内核扩展被加载到了内核的地址空间，而且因此比其它的Mach-O文件类型更难构建。</li>
</ol>
<h2 id="Modules—The_Smallest_Unit_of_Code">Modules—The Smallest Unit of Code</h2><p>在最高等级，你能够把OS X的shared library 当成是一群module的集合，一个module是机器代码和数据的最少单元，它能够独立地链接其它单元的代码。通常来说，一个module时一个产生自单个C源代码文件的对象文件。例如，特定的源代码main.c,thing.c和foo.c，编译器可能产生对象文件main.o,thing.o和foo.o。每个这些输出对象文件都是单个module。当静态链接器被用于整合所有的三个对象文件到dynamic shared library时，每个对象文件被作为一个独立单元的代码和数据引用。当链接程序和bundles时，静态链接器通常联合所有的对象文件到一个module中。<br>静态链接器同样能够减少数个输入modules到单个module中，当构建大多数dynamic shared libraries时，在创建最终share library之前通常是一个好的方法（把多个modules输出到单个module中），因为在多个modules间调用函数会产生少量的额外开销。使用ld，你能够通过下面命令行优化这些性能：<br>ld -r -o things.o thing1.o thing2.o thing3.o<br>使用Xcode的话会自动进行这些优化。</p>
<h2 id="Static_Archive_Libraries">Static Archive Libraries</h2><p>为了聚集模块，你可以使用static archive library，这个是一个拥有内容入口的表的归档文件。格式是使用了ar命令，你可以使用libtool命令去构建一个静态归档库，而且你可以使用ar命令去操作库里的单独模块。<br>除了Mach-O文件外，静态链接器和其他开发工具都接受静态归档库作为输入。你可以使用静态归档库去打包一些你不想在shared library里包含但是又想在多个程序中重复使用的modules。<br>虽然一个ar arvhive能包含任意类型的文件，但经典的原因是以一张内容表把多个对象文件聚合在一起，从而形成一个静态归档库。静态链接器能够把保存在静态归档库中的对象文件链接到Mach-O的执行文件和动态库中。注意你必须在static archive library被使用之前使用libtool命令去创建静态库的内容表，如下：<br>你可以通过libtool命令的static参数去创建一个静态归档库，如下面的命令从中间对象文件thing1.o和thing2.o创建一个名为libting.a静态归档库:<br>libtool -static thing1.o thing2.o -o libthing.a<br>注意如果你不传-static或者-dynamic作为参数，libtool默认是-static参数。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/06/05/building_mach_o_file/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="/2015/06/05/building_mach_o_file/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/05/building_mach_o_file/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-04T11:02:57.000Z"><a href="/2015/06/04/测试，第二篇文章/">周四, 6月 4 2015, 7:02:57 晚上</a></time>

  
    <h1 class="title"><a href="/2015/06/04/测试，第二篇文章/">测试，第二篇文章</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>int Partition(int array[], int length, int start, int end){<br>if (array == NULL || length &lt; 0 || start <0 ||="" end=""> length){<br>return ;<br>}</0></p>
<p>int index = RandomInRange(start, end);<br>swap(&amp;array[index], &amp;array[end]);<br>int small = start - 1;<br>for (index = start ; index &lt; end; ++index){<br>if (array[index] &lt; array[end]){<br>small ++;<br>if (small != index){<br>swap(&amp;array[small], &amp;array[index]);<br>}<br>}<br>}<br>small ++;<br>swap(&amp;array[small], &amp;array[end]);<br>}</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/06/04/测试，第二篇文章/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="/2015/06/04/测试，第二篇文章/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/04/测试，第二篇文章/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-06-04T08:24:43.000Z"><a href="/2015/06/04/my-new-post/">周四, 6月 4 2015, 4:24:43 下午</a></time>

  
    <h1 class="title"><a href="/2015/06/04/my-new-post/">记录新博客我的第一篇文章</a></h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，文章/">博客，文章</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>新建一篇博客，开始一段新的生活。近来下决心搭建了一个属于自己的博客，一来之前写的博文不多，二来近来工作很忙也有点纠结，而且，从开始问人怎么搭建，到自己入手跟着指导文章，再到慢慢地选择修改自己喜欢的主题，把原来主题中一些边边角角也稍微修了一下，终于把博客给搭建起来。起码希望给人简洁的感觉和能人与别人分享技术和生活的点滴吧。作为这篇博客的开端，把近来研究关于苹果构建和运行时方面技术的苹果翻译文和自己的感悟分享一下，希望能把这些东西分享给对这方面的人，也希望从中得到成长。感谢近来给我指导和帮助的人，无论你们在哪里，无论你们准备前往何方，都妥妥地不要忘记初心哈。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/06/04/my-new-post/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="/2015/06/04/my-new-post/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/06/04/my-new-post/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>

<script src="/js/jquery.anystretch.min.js" type="text/javascript"></script>
<script src="/js/cover.js" type="text/javascript"></script>

    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div>
  
  &copy; 2015 Weihao Xu
  
</div>
Powered by <a href="http://zespia.tw/hexo/" title="Hexo" target="_blank" rel="external">Hexo</a> and <a href="http://pages.github.com/" title="GitHub Pages" target="_blank" rel="external">GitHub Pages</a>

<div class="clearfix"></div></footer>
  
<script src="/js/jquery.imagesloaded.min.js" type="text/javascript"></script>
<script src="/js/gallery.js" type="text/javascript"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js" type="text/javascript"></script>




    <script type="text/javascript">
        (function(){
                    $("#main-nav").removeClass('normal_mode').addClass('top_mode');
/*
            $(window).scroll(function(){

                var scrollTop = $(window).scrollTop();
                if ( scrollTop > 0 ){
                    $("#main-nav").removeClass('normal_mode').addClass('top_mode');
                } else{
                    $("#main-nav").removeClass('top_mode').addClass('normal_mode');
                }

            });
*/
        })();
    </script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
  (function($){
    $('.fancybox').fancybox({
      'titlePosition': 'inside'
    });
  })(jQuery);
  </script>



    
    <script type="text/javascript">
      var duoshuoQuery = {short_name:"sky-weihao"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = 'http://static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] 
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>



<script type="text/javascript">
  
  $(function(){

    $('.title').hover(
      function() {      
        $(this).stop().animate(
          {'marginLeft': '10px'}, 200
        );   
      }, 
      function() {       
        $(this).stop().animate({'marginLeft': '0px'}, 200);      
      
    });   

  });

</script>


</body>
</html>