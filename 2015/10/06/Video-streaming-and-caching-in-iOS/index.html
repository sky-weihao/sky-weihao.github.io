<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>iOS音视频实现边下载边播放 | Sky-Weihao的博客</title>
  <meta name="author" content="Weihao Xu">
  
  <meta name="description" content="欢迎光临寒舍">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="iOS音视频实现边下载边播放"/>
  <meta property="og:site_name" content="Sky-Weihao的博客"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/avatar.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Sky-Weihao的博客" type="application/atom+xml">
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-368771XX-X']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>

<body>
  <header id="header" class='normal_mode'>
    <nav id="main-nav">
  <ul class='container'>
    
  </ul>
  <div class="clearfix"></div>
</nav>
  </header>
  <div id="content" class="container">
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-10-06T02:49:41.000Z"><a href="/2015/10/06/Video-streaming-and-caching-in-iOS/">周二, 10月 6 2015, 10:49:41 上午</a></time>

  
    <h1 class="title">iOS音视频实现边下载边播放</h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/blog/">blog</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/博客，原创博客/">博客，原创博客</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>近段时间制作视频播放社区的功能，期间查找了不少资料，做过很多尝试，现在来整理一下其中遇到的一些坑.由于考虑到AVPlayer对视频有更高自由度的控制，而且能够使用它自定义视频播放界面，iOS中所使用的视频播放控件为AVPlayer，而抛弃了高层次的MediaPlayer框架，现在想想挺庆幸当初使用了AVPlayer。</p>
<h3 id="AVPlayer的基本知识">AVPlayer的基本知识</h3><p>AVPlayer本身并不能显示视频，而且它也不像MPMoviePlayerController有一个view属性。如果AVPlayer要显示必须创建一个播放器层AVPlayerLayer用于展示，播放器层继承于CALayer，有了AVPlayerLayer之添加到控制器视图的layer中即可。要使用AVPlayer首先了解一下几个常用的类：</p>
<p>AVAsset：主要用于获取多媒体信息，是一个抽象类，不能直接使用。</p>
<p>AVURLAsset：AVAsset的子类，可以根据一个URL路径创建一个包含媒体信息的AVURLAsset对象。</p>
<p>AVPlayerItem：一个媒体资源管理对象，管理者视频的一些基本信息和状态，一个AVPlayerItem对应着一个视频资源。</p>
<h3 id="iOS视频实现边下载边播放的几种实现">iOS视频实现边下载边播放的几种实现</h3><h4 id="1-本地实现http_server">1.本地实现http server</h4><p>在iOS本地开启Local Server服务，然后使用播放控件请求本地Local Server服务，本地的服务再不断请求视频地址获取视频流，本地服务请求的过程中把视频缓存到本地，这种方法在网上有很多<a href="http://code4app.com/ios/%E8%A7%86%E9%A2%91%E8%BE%B9%E4%B8%8B%E8%BD%BD%E8%BE%B9%E6%92%AD%E6%94%BE/5292c381cb7e8445678b5ac2#" target="_blank" rel="external">例子</a>，有兴趣了解的人可自己下载例子查看。</p>
<h4 id="2-使用AVPlayer的方法开启下载服务">2.使用AVPlayer的方法开启下载服务</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">AVURLAsset</span> *urlAsset = [[<span class="built_in">AVURLAsset</span> alloc]initWithURL:url options:<span class="literal">nil</span>];</span><br><span class="line"><span class="number">2.</span><span class="built_in">AVPlayerItem</span> *item = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:urlAsset];</span><br><span class="line"><span class="number">3.</span>[<span class="keyword">self</span><span class="variable">.avPlayer</span> replaceCurrentItemWithPlayerItem:item];</span><br><span class="line"><span class="number">4.</span>[<span class="keyword">self</span> addObserverToPlayerItem:item];</span><br></pre></td></tr></table></figure>
<p>但由于AVPlayer是没有提供方法给我们直接获取它下载下来的数据，所以我们只能在视频下载完之后自己去寻找缓存视频数据的办法，AVFoundation框架中有一种从多媒体信息类AVAsset中提取视频数据的类AVMutableComposition和AVAssetExportSession。<br>其中AVMutableComposition的作用是能够从现有的asset实例中创建出一个新的AVComposition(它也是AVAsset的字类)，使用者能够从别的asset中提取他们的音频轨道或视频轨道，并且把它们添加到新建的Composition中。<br>AVAssetExportSession的作用是把现有的自己创建的asset输出到本地文件中。<br>为什么需要把原先的AVAsset(AVURLAsset)实现的数据提取出来后拼接成另一个AVAsset(AVComposition)的数据后输出呢，由于通过网络url下载下来的视频没有保存视频的原始数据（或者苹果没有暴露接口给我们获取），下载后播放的avasset不能使用AVAssetExportSession输出到本地文件，要曲线地把下载下来的视频通过重构成另外一个AVAsset实例才能输出。代码例子如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *documentDirectory = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">NSString</span> *myPathDocument = [documentDirectory stringByAppendingPathComponent:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.mp4"</span>,[_source<span class="variable">.videoUrl</span> MD5]]];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURL</span> *fileUrl = [<span class="built_in">NSURL</span> fileURLWithPath:myPathDocument];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asset != <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="built_in">AVMutableComposition</span> *mixComposition = [[<span class="built_in">AVMutableComposition</span> alloc]init];</span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *firstTrack = [mixComposition addMutableTrackWithMediaType:<span class="built_in">AVMediaTypeVideo</span> preferredTrackID:kC<span class="built_in">MPersistentTrackID_Invalid</span>];</span><br><span class="line">[firstTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, asset<span class="variable">.duration</span>) ofTrack:[[asset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>]objectAtIndex:<span class="number">0</span>] atTime:kCMTimeZero error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *audioTrack = [mixComposition addMutableTrackWithMediaType:<span class="built_in">AVMediaTypeAudio</span> preferredTrackID:kC<span class="built_in">MPersistentTrackID_Invalid</span>];</span><br><span class="line">[audioTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, asset<span class="variable">.duration</span>) ofTrack:[[asset tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>]objectAtIndex:<span class="number">0</span>] atTime:kCMTimeZero error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVAssetExportSession</span> *exporter = [[<span class="built_in">AVAssetExportSession</span> alloc]initWithAsset:mixComposition presetName:<span class="built_in">AVAssetExportPresetHighestQuality</span>];</span><br><span class="line">exporter<span class="variable">.outputURL</span> = fileUrl;</span><br><span class="line"><span class="keyword">if</span> (exporter<span class="variable">.supportedFileTypes</span>) &#123;</span><br><span class="line">exporter<span class="variable">.outputFileType</span> = [exporter<span class="variable">.supportedFileTypes</span> objectAtIndex:<span class="number">0</span>] ;</span><br><span class="line">exporter<span class="variable">.shouldOptimizeForNetworkUse</span> = <span class="literal">YES</span>;</span><br><span class="line">[exporter exportAsynchronouslyWithCompletionHandler:^&#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-使用AVAssetResourceLoader回调下载，也是最终决定使用的技术">3.使用AVAssetResourceLoader回调下载，也是最终决定使用的技术</h3><p>AVAssetResourceLoader通过你提供的委托对象去调节AVURLAsset所需要的加载资源。<strong>而很重要的一点是，AVAssetResourceLoader仅在AVURLAsset不知道如何去加载这个URL资源时才会被调用，就是说你提供的委托对象在AVURLAsset不知道如何加载资源时才会得到调用</strong>。所以我们又要通过一些方法来曲线解决这个问题，把我们目标视频URL地址的scheme替换为系统不能识别的scheme，然后在我们调用网络请求去处理这个URL时把scheme切换为原来的scheme。</p>
<p>实现边下边播功能AVResourceLoader的委托对象必须要实现AVAssetResourceLoaderDelegate下五个协议的其中两个：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="comment">//在系统不知道如何处理URLAsset资源时回调</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_9, <span class="number">6</span>_0);</span><br><span class="line"><span class="number">2</span><span class="comment">//在取消加载资源后回调</span></span><br><span class="line">- (<span class="keyword">void</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader didCancelLoadingRequest:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_9, <span class="number">7</span>_0);</span><br></pre></td></tr></table></figure>
<p>以下来说说具体要怎么做处理</p>
<h4 id="第一步，创建一个AVURLAsset，并且用它来初始化一个AVPlayerItem">第一步，创建一个AVURLAsset，并且用它来初始化一个AVPlayerItem</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#define kCustomVideoScheme @<span class="title">"yourScheme"</span></span></span><br><span class="line"><span class="built_in">NSURL</span> *currentURL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://***.***.***"</span>];</span><br><span class="line"><span class="built_in">NSURLComponents</span> *components = [[<span class="built_in">NSURLComponents</span> alloc]initWithURL:currentURL resolvingAgainstBaseURL:<span class="literal">NO</span>];</span><br><span class="line"><span class="number">1</span><span class="comment">////注意，不加这一句不能执行到回调操作</span></span><br><span class="line">components<span class="variable">.scheme</span> = kCustomVideoScheme;</span><br><span class="line"><span class="built_in">AVURLAsset</span> *urlAsset = [<span class="built_in">AVURLAsset</span> URLAssetWithURL:components<span class="variable">.URL</span>  </span><br><span class="line">options:<span class="literal">nil</span>];</span><br><span class="line"><span class="number">2</span><span class="comment">//_resourceManager在接下来讲述</span></span><br><span class="line">[urlAsset<span class="variable">.resourceLoader</span> setDelegate:_resourceManager queue:dispatch_get_main_queue()];</span><br><span class="line"><span class="built_in">AVPlayerItem</span> *item = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:urlAsset];</span><br><span class="line">_playerItem = item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IOS9_OR_LATER) &#123;</span><br><span class="line">item<span class="variable">.canUseNetworkResourcesForLiveStreamingWhilePaused</span> = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.avPlayer</span> replaceCurrentItemWithPlayerItem:item];</span><br><span class="line"><span class="keyword">self</span><span class="variable">.playerLayer</span><span class="variable">.player</span> = <span class="keyword">self</span><span class="variable">.avPlayer</span>;</span><br><span class="line">[<span class="keyword">self</span> addObserverToPlayerItem:item];**</span><br></pre></td></tr></table></figure>
<h4 id="第二步，创建AVResourceManager实现AVResourceLoader协议">第二步，创建AVResourceManager实现AVResourceLoader协议</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> <span class="string">AVAResourceLoaderManager :</span> NSObject &lt; AVAssetResourceLoaderDelegate &gt;</span><br></pre></td></tr></table></figure>
<h4 id="第三步，实现两个必须的回调协议，实现中有几件需要做的事情">第三步，实现两个必须的回调协议，实现中有几件需要做的事情</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">1</span><span class="comment">//获取系统中不能处理的URL</span></span><br><span class="line"><span class="built_in">NSURL</span> *resourceURL = [loadingRequest<span class="variable">.request</span> URL];</span><br><span class="line"><span class="number">2</span><span class="comment">//判断这个URL是否遵守URL规范和其是否是我们所设定的URL</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> checkIsLegalURL:resourceURL] &amp;&amp; [resourceURL<span class="variable">.scheme</span> isEqualToString:kCustomVideoScheme])&#123;</span><br><span class="line"><span class="number">3</span><span class="comment">//判断当前的URL网络请求是否已经被加载过了，如果缓存中里面有URL对应的网络加载器(自己封装，也可以直接使用NSURLRequest)，则取出来添加请求，每一个URL对应一个网络加载器，loader的实现接下来会说明</span></span><br><span class="line"><span class="built_in">AVResourceLoaderForASI</span> *loader = [<span class="keyword">self</span> asiresourceLoaderForRequest:loadingRequest];</span><br><span class="line"><span class="keyword">if</span> (loader == <span class="literal">nil</span>)&#123;</span><br><span class="line">loader = [[<span class="built_in">AVResourceLoaderForASI</span> alloc] initWithResourceURL:resourceURL];</span><br><span class="line">loader<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line"><span class="number">4</span><span class="comment">//缓存网络加载器</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.resourceLoaders</span> setObject:loader forKey:[<span class="keyword">self</span> keyForResourceLoaderWithURL:resourceURL]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span><span class="comment">//加载器添加请求</span></span><br><span class="line">[loader addRequest:loadingRequest];</span><br><span class="line"><span class="number">6</span><span class="comment">//返回YES则表明使用我们的代码对AVAsset中请求网络资源做处理</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader didCancelLoadingRequest:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果用户在下载的过程中调用者取消了获取视频,则从缓存中取消这个请求</span></span><br><span class="line"><span class="built_in">NSURL</span> *resourceURL = [loadingRequest<span class="variable">.request</span> URL];</span><br><span class="line"><span class="built_in">NSString</span> *actualURLString = [<span class="keyword">self</span> actualURLStringWithURL:resourceURL];</span><br><span class="line"><span class="built_in">AVResourceLoaderForASI</span> *loader = [_resourceLoaders objectForKey:actualURLString];</span><br><span class="line">[loader removeRequest:loadingRequest];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第四步，判断缓存中是否已下载完视频">第四步，判断缓存中是否已下载完视频</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addRequest:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1判断自身是否已经取消加载</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">self</span><span class="variable">.isCancelled</span>==<span class="literal">NO</span>)&#123;</span><br><span class="line"><span class="comment">//2判断本地中是否已经有文件的缓存，如果有，则直接从缓存中读取数据，文件保存和读取这里不做详述，使用者可根据自身情况创建文件系统</span></span><br><span class="line"><span class="built_in">AVAResourceFile</span> *resourceFile = [<span class="keyword">self</span><span class="variable">.resourceFileManager</span> resourceFileWithURL:<span class="keyword">self</span><span class="variable">.resourceURL</span>];</span><br><span class="line"><span class="keyword">if</span> (resourceFile) &#123;</span><br><span class="line"><span class="comment">//3若本地文件存在，则从文件中获取以下属性  </span></span><br><span class="line">loadingRequest<span class="variable">.contentInformationRequest</span><span class="variable">.byteRangeAccessSupported</span> = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">//3.1contentType</span></span><br><span class="line">loadingRequest<span class="variable">.contentInformationRequest</span><span class="variable">.contentType</span> = resourceFile<span class="variable">.contentType</span>;</span><br><span class="line"><span class="comment">//3.2数据长度          		  </span></span><br><span class="line">loadingRequest<span class="variable">.contentInformationRequest</span><span class="variable">.contentLength</span> = resourceFile<span class="variable">.contentLength</span>;</span><br><span class="line"><span class="comment">//3.3请求的偏移量</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> requestedOffset = loadingRequest<span class="variable">.dataRequest</span><span class="variable">.requestedOffset</span>;</span><br><span class="line"><span class="comment">//3.4请求总长度</span></span><br><span class="line"><span class="built_in">NSInteger</span> requestedLength = loadingRequest<span class="variable">.dataRequest</span><span class="variable">.requestedLength</span>;</span><br><span class="line"><span class="comment">//3.5取出本地文件中从偏移量到请求长度的数据</span></span><br><span class="line"><span class="built_in">NSData</span> *subData = [resourceFile<span class="variable">.data</span> subdataWithRange:<span class="built_in">NSMakeRange</span>(@(requestedOffset)<span class="variable">.unsignedIntegerValue</span>, requestedLength)];</span><br><span class="line"><span class="comment">//3.6返回数据给请求</span></span><br><span class="line">[loadingRequest<span class="variable">.dataRequest</span> respondWithData:subData];</span><br><span class="line">[loadingRequest finishLoading];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//4如果没有本地文件，则开启网络请求，从网络中获取 ,见第五步 </span></span><br><span class="line">[<span class="keyword">self</span> startWithRequest:loadingRequest];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//5如果已经取消请求，并且请求没有完成，则封装错误给请求，可自己实现</span></span><br><span class="line"><span class="keyword">if</span>(loadingRequest<span class="variable">.isFinished</span>==<span class="literal">NO</span>)&#123;</span><br><span class="line">[loadingRequest finishLoadingWithError:[<span class="keyword">self</span> loaderCancelledError]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第五步，添加loadingRequest到网络文件加载器，这部分的操作比较长">第五步，添加loadingRequest到网络文件加载器，这部分的操作比较长</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startWithRequest:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">1</span><span class="comment">//判断当前请求是否已经开启，由于苹果系统原因，会有两次回调到AVResourceLoaderDelegate，我们对其进行判断，只开启一次请求</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.dataTask</span> == <span class="literal">nil</span>)&#123;</span><br><span class="line"><span class="number">2</span><span class="comment">//根据loadingRequest中的URL创建NSURLRequest，注意在此把URL中的scheme修改为原先的scheme</span></span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="keyword">self</span> requestWithLoadingRequest:loadingRequest];</span><br><span class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="number">3</span><span class="comment">//获取url的绝对路径，并使用ASIHttpRequest进行网络请求，下面的请求方法经过封装，就不详说如何对ASI进行封装了，但是每一步需要做的事情能以block的形式更好说明</span></span><br><span class="line"><span class="built_in">NSString</span> *urlString = request<span class="variable">.URL</span><span class="variable">.absoluteString</span>;</span><br><span class="line"><span class="keyword">self</span><span class="variable">.dataTask</span> = [<span class="keyword">self</span> GET:urlString requestBlock:^(Request *req) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s %@ ###"</span>, __func__, req);</span><br><span class="line"><span class="number">4</span><span class="comment">//在接受到请求头部信息时，说明链接成功，数据开始传输</span></span><br><span class="line"><span class="keyword">if</span> (req<span class="variable">.recvingHeader</span><span class="comment">//意思是请求接受到头部信息状态)&#123;</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s recvingHeader ###"</span>, __func__);</span><br><span class="line">__<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"><span class="keyword">if</span> ([urlString isEqualToString:req<span class="variable">.originalURL</span><span class="variable">.absoluteString</span>]) &#123;</span><br><span class="line"><span class="number">4.1</span><span class="comment">//，创建临时数据保存网络下载下来的视频信息</span></span><br><span class="line">strongSelf<span class="variable">.tempData</span> = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4.2</span><span class="comment">//把头部信息内容写入到AVAssetResourceLoadingRequest，即loadingRequest中</span></span><br><span class="line">[strongSelf processPendingRequests];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (req<span class="variable">.recving</span><span class="comment">//请求接受中状态)&#123;</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s recving ###"</span>, __func__);</span><br><span class="line">__<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"><span class="number">5</span><span class="comment">//此处需多次调用把请求的信息写入到loadingRequest的步骤，实现下载的过程中数据能输出到loadingRequest播放</span></span><br><span class="line"><span class="keyword">if</span> (urlString == req<span class="variable">.originalURL</span><span class="variable">.absoluteString</span>) &#123;</span><br><span class="line"><span class="number">5.1</span><span class="comment">//这个处理是判断此时返回的头部信息是重定向还是实际视频的头部信息，如果是重定向信息，则不作处理</span></span><br><span class="line"><span class="keyword">if</span> (!_contentInformation &amp;&amp; req<span class="variable">.responseHeaders</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ([req<span class="variable">.responseHeaders</span> objectForKey:<span class="string">@"Location"</span>] ) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@" ### %s redirection URL ###"</span>, __func__);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//5.2如果不是重定向信息，则把需要用到的信息提取出来</span></span><br><span class="line">_contentInformation = [[RLContentInformationForASI alloc]init];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> numer = [[req<span class="variable">.responseHeaders</span> objectForKey:<span class="string">@"Content-Length"</span>]longLongValue];</span><br><span class="line">_contentInformation<span class="variable">.contentLength</span> = numer;</span><br><span class="line">_contentInformation<span class="variable">.byteRangeAccessSupported</span> = <span class="literal">YES</span>;</span><br><span class="line">_contentInformation<span class="variable">.contentType</span> = [req<span class="variable">.responseHeaders</span> objectForKey:<span class="string">@"Content-type"</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.3开始从请求中获取返回数据</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s before tempData length = %lu ###"</span>, __FUNCTION__, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span><span class="variable">.tempData</span><span class="variable">.length</span>);</span><br><span class="line">strongSelf<span class="variable">.tempData</span> = [<span class="built_in">NSMutableData</span> dataWithData:req<span class="variable">.rawResponseData</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s after tempData length = %lu ###"</span>,__FUNCTION__, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span><span class="variable">.tempData</span><span class="variable">.length</span>);</span><br><span class="line"><span class="comment">//5.4把返回数据输出到loadingRequest中</span></span><br><span class="line">[strongSelf processPendingRequests];</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (req<span class="variable">.succeed</span>)&#123;</span><br><span class="line"><span class="number">6</span><span class="comment">//请求返回成功，在这里做最后一次把数据输出到loadingRequest，且做一些成功后的事情</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s succeed ###"</span>, __func__);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s tempData length = %lu ###"</span>, __func__, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span><span class="variable">.tempData</span><span class="variable">.length</span>);</span><br><span class="line">__<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"><span class="keyword">if</span> (strongSelf) &#123;</span><br><span class="line">[strongSelf processPendingRequests];</span><br><span class="line"></span><br><span class="line"><span class="number">7</span><span class="comment">//保存缓存文件，我在保存文件这里做了一次偷懒，如果有人参考我写的文件可对保存文件作改进，在每次返回数据时把数据追加写到文件，而不是下载成功之后才保存，这请求时也可以使用这个来实现断点重输的功能</span></span><br><span class="line"><span class="built_in">AVAResourceFile</span> *resourceFile = [[<span class="built_in">AVAResourceFile</span> alloc]initWithContentType:strongSelf<span class="variable">.contentInformation</span><span class="variable">.contentType</span> date:strongSelf<span class="variable">.tempData</span>];</span><br><span class="line">[strongSelf<span class="variable">.resourceFileManager</span> saveResourceFile:resourceFile withURL:<span class="keyword">self</span><span class="variable">.resourceURL</span>];</span><br><span class="line"><span class="number">8</span><span class="comment">//在此做一些清理缓存、释放对象和回调到上层的操作</span></span><br><span class="line">[strongSelf complete];</span><br><span class="line"><span class="keyword">if</span> (strongSelf<span class="variable">.delegate</span> &amp;&amp; [strongSelf<span class="variable">.delegate</span> respondsToSelector:<span class="keyword">@selector</span>(resourceLoader:didLoadResource:)]) &#123;</span><br><span class="line">[strongSelf<span class="variable">.delegate</span> resourceLoader:strongSelf didLoadResource:strongSelf<span class="variable">.resourceURL</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (req<span class="variable">.failed</span>)&#123;</span><br><span class="line"><span class="comment">//9如果请求返回失败，则向上层抛出错误，且清理缓存等操作</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"### %s failed ###"</span> , __func__);</span><br><span class="line">[<span class="keyword">self</span> completeWithError:req<span class="variable">.error</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.pendingRequests</span> addObject:loadingRequest];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第六步，把请求返回数据输出到loadingRequest的操作">第六步，把请求返回数据输出到loadingRequest的操作</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)processPendingRequests</span><br><span class="line">&#123;</span><br><span class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">__<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *requestsCompleted = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="number">1</span><span class="comment">//从缓存信息中找出当前正在请求中的loadingRequest</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">AVAssetResourceLoadingRequest</span> *loadingRequest <span class="keyword">in</span> strongSelf<span class="variable">.pendingRequests</span>)&#123;</span><br><span class="line"><span class="number">2</span><span class="comment">//把头部信息输出到loadingRequest中</span></span><br><span class="line">[strongSelf fillInContentInformation:loadingRequest<span class="variable">.contentInformationRequest</span>];      </span><br><span class="line"><span class="number">3</span><span class="comment">//把视频数据输出到loadingRequest中</span></span><br><span class="line"><span class="built_in">BOOL</span> didRespondCompletely = [strongSelf respondWithDataForRequest:loadingRequest<span class="variable">.dataRequest</span>];</span><br><span class="line"><span class="number">4</span><span class="comment">//在success状态中做最后一次调用的时候，检测到请求已经完成，则从缓存信息中清除loadingRequest，并且把loadingRequest标志为完成处理状态</span></span><br><span class="line"><span class="keyword">if</span> (didRespondCompletely)&#123;</span><br><span class="line">[requestsCompleted addObject:loadingRequest];</span><br><span class="line">[loadingRequest finishLoading];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span><span class="comment">//清理缓存</span></span><br><span class="line">[strongSelf<span class="variable">.pendingRequests</span> removeObjectsInArray:requestsCompleted];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">、</span><br><span class="line"></span><br><span class="line"><span class="comment">//把提取出来的头部信息输出到loadingRequest中，可以优化</span></span><br><span class="line">- (<span class="keyword">void</span>)fillInContentInformation:(<span class="built_in">AVAssetResourceLoadingContentInformationRequest</span> *)contentInformationRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (contentInformationRequest == <span class="literal">nil</span> || <span class="keyword">self</span><span class="variable">.contentInformation</span> == <span class="literal">nil</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">contentInformationRequest<span class="variable">.byteRangeAccessSupported</span> = <span class="keyword">self</span><span class="variable">.contentInformation</span><span class="variable">.byteRangeAccessSupported</span>;</span><br><span class="line">contentInformationRequest<span class="variable">.contentType</span> = <span class="keyword">self</span><span class="variable">.contentInformation</span><span class="variable">.contentType</span>;</span><br><span class="line">contentInformationRequest<span class="variable">.contentLength</span> = <span class="keyword">self</span><span class="variable">.contentInformation</span><span class="variable">.contentLength</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把缓存数据输出到loadingRequest中</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)respondWithDataForRequest:(<span class="built_in">AVAssetResourceLoadingDataRequest</span> *)dataRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> startOffset = dataRequest<span class="variable">.requestedOffset</span>;</span><br><span class="line"><span class="keyword">if</span> (dataRequest<span class="variable">.currentOffset</span> != <span class="number">0</span>)&#123;</span><br><span class="line">startOffset = dataRequest<span class="variable">.currentOffset</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don't have any data at all for this request</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.tempData</span><span class="variable">.length</span> &lt; startOffset)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is the total data we have from startOffset to whatever has been downloaded so far</span></span><br><span class="line"><span class="built_in">NSUInteger</span> unreadBytes = <span class="keyword">self</span><span class="variable">.tempData</span><span class="variable">.length</span> - (<span class="built_in">NSUInteger</span>)startOffset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Respond with whatever is available if we can't satisfy the request fully yet</span></span><br><span class="line"><span class="built_in">NSUInteger</span> numberOfBytesToRespondWith = MIN((<span class="built_in">NSUInteger</span>)dataRequest<span class="variable">.requestedLength</span>, unreadBytes);</span><br><span class="line"></span><br><span class="line">[dataRequest respondWithData:[<span class="keyword">self</span><span class="variable">.tempData</span> subdataWithRange:<span class="built_in">NSMakeRange</span>((<span class="built_in">NSUInteger</span>)startOffset, numberOfBytesToRespondWith)]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> endOffset = startOffset + dataRequest<span class="variable">.requestedLength</span>;</span><br><span class="line"><span class="built_in">BOOL</span> didRespondFully = <span class="keyword">self</span><span class="variable">.tempData</span><span class="variable">.length</span> &gt;= endOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> didRespondFully;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>视频边下边播的流程大致上已经描述完毕，本博文中没有说到的代码有错误处理方式、缓存文件的读写和保存格式、部分内存缓存使用说明、</strong></p>
<p>参考链接：<br><a href="http://www.codeproject.com/Articles/875105/Audio-streaming-and-caching-in-iOS-using" target="_blank" rel="external">http://www.codeproject.com/Articles/875105/Audio-streaming-and-caching-in-iOS-using</a><br><a href="http://www.cnblogs.com/kenshincui/p/4186022.html#mpMoviePlayerController" target="_blank" rel="external">http://www.cnblogs.com/kenshincui/p/4186022.html#mpMoviePlayerController</a></p>

      
    </div>
    <footer>
      

          <div class="clearfix"></div>
          <nav id="pagination">
  
  
    <a href="/2015/07/22/总结一些有用的iOS工具/" class="alignright next">Prev<i class="fa fa-long-arrow-right"></i></a>
  
  <div class="clearfix"></div>
</nav>
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
      <!-- Duoshuo Comment BEGIN -->
<div class="ds-thread" data-thread-key="/2015/10/06/Video-streaming-and-caching-in-iOS/"></div>
<!-- Duoshuo Comment END -->
  
</section>



    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div>
  
  &copy; 2015 Weihao Xu
  
</div>
Powered by <a href="http://zespia.tw/hexo/" title="Hexo" target="_blank" rel="external">Hexo</a> and <a href="http://pages.github.com/" title="GitHub Pages" target="_blank" rel="external">GitHub Pages</a>

<div class="clearfix"></div></footer>
  
<script src="/js/jquery.imagesloaded.min.js" type="text/javascript"></script>
<script src="/js/gallery.js" type="text/javascript"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js" type="text/javascript"></script>




    <script type="text/javascript">
        (function(){
                    $("#main-nav").removeClass('normal_mode').addClass('top_mode');
/*
            $(window).scroll(function(){

                var scrollTop = $(window).scrollTop();
                if ( scrollTop > 0 ){
                    $("#main-nav").removeClass('normal_mode').addClass('top_mode');
                } else{
                    $("#main-nav").removeClass('top_mode').addClass('normal_mode');
                }

            });
*/
        })();
    </script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
  (function($){
    $('.fancybox').fancybox({
      'titlePosition': 'inside'
    });
  })(jQuery);
  </script>



    
    <script type="text/javascript">
      var duoshuoQuery = {short_name:"sky-weihao"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = 'http://static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] 
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>



<script type="text/javascript">
  
  $(function(){

    $('.title').hover(
      function() {      
        $(this).stop().animate(
          {'marginLeft': '10px'}, 200
        );   
      }, 
      function() {       
        $(this).stop().animate({'marginLeft': '0px'}, 200);      
      
    });   

  });

</script>


</body>
</html>